{
    "docs": [
        {
            "location": "/", 
            "text": "Documentation for the \nmeep\n adjoint module\nbegins \nhere\n.", 
            "title": "Adjoint Module"
        }, 
        {
            "location": "/AdjointSolver/Overview/", 
            "text": "$$\n   \\newcommand{\\vb}{\\mathbf}\n   \\newcommand{\\wt}{\\widetilde}\n   \\newcommand{\\mc}{\\mathcal}\n   \\newcommand{\\bmc}[1]{\\boldsymbol{\\mathcal{#1}}}\n   \\newcommand{\\sup}[1]{^{\\text{#1}}}\n   \\newcommand{\\sups}[1]{^{\\text{#1}}}\n   \\newcommand{\\sub}[1]{_{\\text{#1}}}\n   \\newcommand{\\subs}[1]{_{\\text{#1}}}\n   \\newcommand{\\pard}[2]{\\frac{\\partial #1}{\\partial #2}}\n   \\newcommand{\\VMV}[3]{ \\Big\\langle #1 \\Big| #2 \\Big| #3 \\Big\\rangle}\n$$\n\n\n\n.superfences-tabs {\n  display: flex;\n  position: relative;\n  flex-wrap: wrap;\n}\n\n.superfences-tabs .highlight {\n  background: #ddd;\n}\n\n.superfences-tabs .superfences-content {\n  display: none;\n  order: 99;\n  width: 100%;\n}\n\n.superfences-tabs label {\n  width: auto;\n  margin: 0 0.5em;\n  padding: 0.25em;\n  font-size: 120%;\n  cursor: pointer;\n}\n\n.superfences-tabs input {\n  position: absolute;\n  opacity: 0;\n}\n\n.superfences-tabs input:nth-child(n+1) {\n  color: #333333;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label {\n    color: #FF5252;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label + .superfences-content {\n    display: block;\n}\n\n\n\n\n\n\nmeep\n.\nadjoint\n:\n Adjoint sensitivity analysis for automated design optimization\n\n\n\n\nThis section of the \nmeep\n documentation\ncovers \nmeep\n.\nadjoint\n,\n a submodule of the \nmeep\n python module\nthat implements an \nadjoint-based sensitivity solver\n\nto facilitate automated design optimization via derivative-based numerical optimizers.\n\n\n\n\n \ntable of contents\n\n\nThe \nmeep.adjoint\n documentation is divided into a number of subsections:\n\n\n\n\n\n\nThis \nOverview\n page reviews some basic facts about adjoints and optimizers,\n  outlines the steps needed to prepare a \nmeep\n\n  geometry for optimization, and sketches the mechanics of\n  the \nmeep.adjoint\n design process.\n  (This page is designed to be a gentle introduction for the\n  adjoint neophyte; experts may want only to skim it before\n  skipping to the next section.)\n\n\n\n\n\n\nThe \nReference Manual\n fills in the details of \n  the topics outlined on this page, spelling out exactly how to\n  write the python script that will drive your optimization\n  session.\n\n\n\n\n\n\nThe \nExample Gallery\n presents a number\n  of worked examples that illustrate how \nmeep.adjoint\n tackles\n  practical problems in various settings.\n\n\n\n\n\n\nThe \nImplementation Notes\n page\n  offers a glimpse of what's behind the hood---the physical \n   and mathematical basis of the adjoint method and how they\n  are implemented by \nmeep.adjoint.\n An understanding of this \n  content is not strictly necessary to use the solver, but may\n  help you get more out of the process.\n\n\n\n\n\n\nAlthough logically independent of the adjoint solver,\n  the \nVisualization\n package bundled\n with the \nmeep.adjoint\n module offers several general-purpose\n  utilities for convenient visualization of various aspects\n of \nmeep\n calculations, which are\n useful in \nany\n meep calculation whether adjoint-related\n or not.\n\n\n\n\n\n\n\n\nOverview: Adjoint-based optimization\n\n\nA common task in electromagnetic engineering is to custom-tune the design\nof some component of a system---a waveguide taper, a power splitter,\nan input coupler, an antenna, etc.---to optimize the performance of the system\nas defined by some problem-specific metric. For our purposes,\na \"design\" will consist of a specification of the spatially-varying\nscalar permittivity \n\\epsilon(\\mathbf x)\n\\epsilon(\\mathbf x)\n in some subregion\nof a \nmeep\n geometry, and the performance metric\nwill be a physical quantity computed from frequency-domain\nfields---a \npower flux\n,\nan \nenergy density\n,\nan\n\neigenmode expansion coefficient\n,\nor perhaps some mathematical function of one or more of these\nquantities. We will shortly present a smorgasbord of examples; for now,\nperhaps a good one to have in mind is the\n\nhole cloak \n discussed below, in which a\nchunk of material has been removed from an otherwise perfect waveguide\nsection, ruining the otherwise perfectly unidirectional (no scattering or reflection)\nflow of power from a source at one end of the guide to a sink at the other;\nour task is to tweak the permittivity in an annular region\nsurrounding the defect (the \ncloak\n) so as to restore \nas much as possible the reflectionless transfer of power \nacross the waveguide---thus hiding or \"cloaking\"\nthe presence of defect from external detection.\n\n\nNow, given a candidate design\n\n\\epsilon\\sup{trial}(\\mathbf{x})\n\\epsilon\\sup{trial}(\\mathbf{x})\n, it's easy enough to see\nhow we can use \nmeep\n to evaluate\nits performance---just create a\n\nmeep\n geometry with \n\\epsilon\\sup{trial}\n\\epsilon\\sup{trial}\n as a\n\nspatially-varying permittivity function\n,\nin the design region,\nadd \nDFT cells\n\nto tabulate the frequency-domain Poynting flux entering and departing\nthe cloak region,\n\ntimestep\n until\nthe DFTs converge, then use post-processing routines like\n\nget_fluxes\n(\n)\n\nor perhaps\n\nget_eigenmode_coefficients\n()\n\nto get the quantities needed to evaluate the performance of the device.\nThus, for the cost of one full \nmeep\n timestepping\nrun we obtain the value of our objective function at one point\nin the parameter space of possible inputs. \n\n\nBut \nnow\n what do we do?! The difficulty is that the computation\nizinust described furnishes only the \nvalue\n of the objective function\nfor a given input, not its \nderivatives\n with respect to the\ndesign variables---and thus yields zero insight into how we should\ntweak the design to improve performance.\nIn simple cases we might hope to proceed on the basis of physical\nintuition, while\nfor small problems with just a few parameters we might try our luck with a\n\nderivative-free optimization algorithm\n;\nhowever, both of these approaches will run out of steam long before\nwe scale up to \nthe full complexity of a practical problem with thousands\nof degrees of freedom.\nAlternatively, we could get approximate derivative information by brute-force\nfinite-differencing---slightly tweaking one design variable, repeating \nthe full timestepping run, and asking how the results changed---but \nproceeding this way to compute derivatives with respect to all \nD\nD\n \ndesign variables would require fully \nD\nD\n separate timestepping runs;\nfor the problem sizes we have in mind, this would make calculating the \nobjective-function gradient\n\nseveral thousand times\n more costly than calculating its value.\nSo we face a dilemma: How can we obtain the derivative information\nnecessary for effective optimization in a reasonable amount of time?\nThis is where adjoints come to the rescue.\n\n\nThe \nadjoint method\n of sensitivity analysis is a technique in which\nwe exploit certain facts about the physics of a problem and the\nconsequent mathematical structure---specifically, in this case, the\nlinearity and reciprocity of Maxwell's equations---to rearrange the\ncalculation of derivatives in a way that yields an \nenormous\n speedup\nover the brute-force finite-difference approach. More specifically,\nafter we have computed the objective-function value by doing\nthe full \nmeep\n timestepping run mentioned\nabove---the \"forward\" run in adjoint-method parlance---we can magically\ncompute its derivatives with respect to \nall\n design variables by doing\njust \none\n additional timestepping run with a funny-looking choice\nof sources and outputs (the \"adjoint\" run).\nThus, whereas gradient computation via finite-differencing is at least \nD\nD\n\ntimes more expensive than computing the objective function value,\nwith adjoints we get both value and gradient for roughly just \ntwice\n the\ncost of the value alone. Such a bargain! At this modest cost, derivative-based \noptimization becomes entirely feasible.\n\n\n\n\n \nMore general materials\n\n    Although for simplicity we focus here on case of isotropic,\n    non-magnetic materials, the adjoint solver is also capable\n    of optimizing geometries involving permeable (\n\\mu\\ne 1\n\\mu\\ne 1\n) and\n    anisotropic (tensor-valued \n\\boldsymbol{\\epsilon},\\boldsymbol{\\mu}\n\\boldsymbol{\\epsilon},\\boldsymbol{\\mu}\n) media.\n\n\n\n\n\n\nExamples of optimization problems\n\n\nThroughout the \nmeep.adjoint\n documentation we will refer to a running collection of \nsimple optimization problems to illustrate the mechanics of optimization,\namong which are the following; click the geometry images to view \nin higher resolution.   \n\n\n\n\nThe Holey Waveguide\n\n\nBy way of warm-up, a useful toy version of an optimization problem\nis an otherwise pristine length of dielectric slab waveguide in\nwhich a careless technician has torn a circular \nhole\n of variable\npermittivity \n\\epsilon\\sup{hole}\n\\epsilon\\sup{hole}\n.     \n\n\n\n\n\n\n\n\n\n\nIncident power from an\n\neigenmode source\n (cyan line in figure)\ntravels leftward through the waveguide, but is partially \nreflected by the hole, resulting in less than 100% power\nthe waveguide output (as may be \ncharacterized in \nmeep\n\nby observing power flux and/or\neigenmode expansion coefficients at the two \nflux monitors, labeled \neast\n and \nwest\n).\nOur objective is to tweak the value of\n\n\\epsilon\\sup{hole}\n\\epsilon\\sup{hole}\n to maximize transmission\nas assessed by one of these metrics.\nThe simplicity of this model makes it a useful\ninitial warm-up and sanity check for making sure we know\nwhat we are doing in design optimization; for example, \n\nin this worked example\n\nwe use it to confirm the numerical accuracy of\nadjoint-based gradients computed by \nmp.adjoint\n\n\n\n\nThe Hole Cloak\n\n\nWe obtain a more challenging variant of the holey-waveguide problem\nbe supposing that the material in the hole region is \nnot\n a\ntunable design parameter---it is fixed at vacuum, say, or \nperfect metal---but that we \nare\n allowed to vary the permittivity\nin an annular region surrounding the hole in such a way\nas to mimic the effect of filling in the hole, i.e. of hiding\nor \"cloaking\" the hole  as much as  possible from external \n detection.\n\n\n\n\n\n\n\n\n\n\nFor the hole-cloak optimization, the objective function\nwill most likely the same as that considered above---namely,\nto maximize the Poynting flux through the flux monitor\nlabeled \neast\n (a quantity we label \nS\\subs{east}\nS\\subs{east}\n)\n or perhaps to maximize the overlap coefficient\nbetween the actual fields passing through monitor\n\neast\n and the fields of (say)\nthe \nn\nn\nth forward- or backward-traveling eigenmode\nof the waveguide (which we label \n\\{P,M\\}_{n,\\text{east}}\n\\{P,M\\}_{n,\\text{east}}\n\nwith \nP,M\nP,M\n standing for \"plus and minus.\")\nOn the other hand, the design space here is more \ncomplicated than for the simple hole, consisting\nof all possible scalar functions \n\\epsilon(r,\\theta)\n\\epsilon(r,\\theta)\n \ndefined on the annular cloak region.\n\n\n\n\nThe cross-router\n\n\nA different flavor of waveguide-optimization problem arises when we\nconsider the \nrouting\n of signals from given inputs to \ngiven destinations. One example is the \ncross-router\n, involving\nan intersection between \nx-\nx-\ndirected and \ny-\ny-\ndirected waveguides,\nwith center region of variable permittivity that we may\ntweak to control the routing of power through it.\n\n\n\n\n\n\n\n\n\n\nWhereas in the previous examples there was more or less\nonly one reasonable design objective one might realistically\nwant to optimize,\nfor a problem like this there are many possibilities.\nFor example, given fixed input power supplied by an eigenmode\nsource on the \"western\" branch (cyan line),\nwe might be less interested in the absolute output\npower at any port and more concerned with \nachieving maximal \nequality\n of output \npower among the north, south, and east outputs,\nwhereupon we might minimize an objective function of\nthe form\n$$f\\sub{obj}  =\n   \\Big( S\\sub{north} - S\\sub{south}\\Big)^2\n  +\\Big( S\\sub{north} - S\\sub{east}\\Big)^2\n + \\Big( S\\sub{east} - S\\sub{south}\\Big)^2\n$$\n(or a similar functional form involving eigenmode \ncoefficients).\nAlternatively, perhaps we don't care what happens in\nthe southern branch, but we really want the fields \ntraveling past the \nnorth\n monitor \nto have twice as much\noverlap with the forward-traveling 3\nrd\n eigenmode of that\nwaveguide \nas the \neast\n fields have with their backward-traveling\n2\nnd\n eigenmode:\n\n\n\n\n f\\sub{obj} \\equiv \\Big( P\\sub{3,north} - 2M\\sub{2,east}\\Big)^2\n\n\n f\\sub{obj} \\equiv \\Big( P\\sub{3,north} - 2M\\sub{2,east}\\Big)^2\n\n\n\n\nThe point is that the definition of an optimization problem\ninvolves not only a set of physical quantities  (power fluxes, eigenmode coefficients,\netc.) that we compute from \nmeep\n calculations,\nbut also a rule (the objective function \nf\nf\n) for crunching those \nnumbers in some specific way to define a single scalar figure of merit. \n\n\nIn  \nmp.adjoint\n we use the collective term \nobjective quantities\n\nfor the power fluxes, eigenmode coefficients, and other physical quantities\nneeded to compute the objective function.\nSimilarly, the special geometric subregions of \n\nmeep\n geometries with\nwhich objective quantities are associated---the\ncross-sectional flux planes of \nDFTFlux\n cells or \nfield-energy boxes of \nDFTField\n cells----are known as \nobjective regions.\n\n\nThe [Example Gallery][ExampleGallery.md] includes a worked example\nof a full successful iterative optimization in which\n\nmp.adjoint\n begins with the design shown above and thoroughly rejiggers\nit over the course of 50 iterations to yield a device\nthat efficiently routs power around a 90\n bend\nfrom the eigenmode source (cyan line above)\nto the 'north' output port.\n\n\n\n\nThe asymmetric splitter\n\n\nA \nsplitter\n seeks to divide incoming power from one source\nin some specific way among two or more destinations.,\nWe will consider an asymmetric splitter in which power\narriving from a single incoming waveguide is to be routed\ninto two outgoing waveguides by varying the design of the \ncentral coupler region:\n\n\n\n\n\n\n\n\n\n\n\n\nCommon elements of optimization geometries: Objective regions, objective functions, design regions, basis sets\n\n\nThe examples above, distinct though they all are, illustrate\nthe common defining features that are present in every\n\nmeep\n optimization problem:\n\n\n\n\nObjective regions:\n One or more \nregions over which to tabulate frequency-domain fields (DFT cells)\n\n  for use in computing power fluxes, mode-expansion coefficients, and other frequency-domain\n   quantities used in characterizing device performance.  Because these regions are used to evaluate\n   objective functions, we refer to them as \nobjective regions.\n\n\n\n\n\n\n \nObjective regions may or may not have zero thickness\n\n    In the examples above, it happens that all objective regions are one-dimensional\n    (zero-thickness) flux monitors, indicated by magenta lines; in a 3D geometry they\n    would be two-dimensional flux planes, still of zero thickness in the normal \n    direction.  However, objective regions may also be of nonzero thickness, as for\n    instance if the objective function involves the \nfield energy in a box-shaped\n    subregion of a geometry.\n\n\n\n\n\n\n\n\nObjective quantities and the objective function:\n \n      A specification of which quantities (power fluxes, mode coefficients,\n      energies, etc.) are to be computed for each objective region, and how\n      those quantities are to be crunched mathematically to yield a single number \n      measuring device performance. We refer to the individual quantities as \n      \nobjective quantities\n, while the overall function that inputs one more more\n      objective quantities and outputs a single numerical score is the \n      \nobjective function.\n\n\n\n\n\n\nDesign region:\n A specification of the region over which the material design is to be\n    optimized, i.e. the region in which the permittivity is given by the\n    design quantity \n\\epsilon\\sup{des}(\\mathbf x)\n\\epsilon\\sup{des}(\\mathbf x)\n.\n    We refer to this as the \ndesign region\n \n\\mathcal{V}\\sup{des}\n\\mathcal{V}\\sup{des}\n.\n\n\n\n\n\n\nBasis:\n Because the design variable \n\\epsilon\\sup{des}(\\mathbf x)\n\\epsilon\\sup{des}(\\mathbf x)\n\n    is a continuous function defined throughout a finite volume of space,\n    technically it involves infinitely many degrees of freedom.\n    To yield a finite-dimensional optimization problem, it is convenient\n    to approximate \n\\epsilon\\sup{des}\n\\epsilon\\sup{des}\n as a finite expansion in some\n    convenient set of basis functions, i.e.\n    $$ \\epsilon(\\mathbf x) \\equiv \\sum_{d=1}^N \\beta_d \\mathcal{b}_d(\\mathbf x),\n       \\qquad \\mathbf x\\in \\mathcal{V}\\sup{des},\n    $$\n    where \n\\{\\mathcal{b}_n(\\mathbf x)\\}\n\\{\\mathcal{b}_n(\\mathbf x)\\}\n is a set of \nD\nD\n scalar-valued\n    basis functions defined for \n\\mathbf x\\in\\mathcal{V}\\sup{des}\n\\mathbf x\\in\\mathcal{V}\\sup{des}\n.\n    The task of the optimizer then becomes to determine\n    numerical values for the \nN\nN\n-vector of coefficients \n    \n\\boldsymbol{\\beta}=\\{\\beta_n\\},n=1,\\cdots,N.\n\\boldsymbol{\\beta}=\\{\\beta_n\\},n=1,\\cdots,N.\n\n\nFor adjoint optimization in \nmeep\n, the\nbasis set is chosen by the user, either from among a predefined collection of\ncommon basis sets, or as an arbitrary user-defined basis set specified by\nsubclassing an abstract base class in \nmp.adjoint.\n\n\n\n\n\n\nMechanics of \nmeep\n design optimization\n\n\nWith all that by way of background, here's a quick rundown of the \nprocess you'll follow to optimize a geometry in \nmeep.adjoint.\n\n\n\n\nYou write a python script that implements a subclass of\n   \nOptimizationProblem\n (an abstract base class in \nmeep.adjoint\n)\n   to describe your specific problem. In particular, your \n   class must override the following two pure virtual methods\n   in \nOptimizationProblem:\n\n\n\n\ninit_problem\n: One-time initialization\nInputs an \nargs\n structure describing command-line options\nand returns a 5-tuple\n\n   \nfstr\n,\n \nobjective_regions\n,\n \nextra_regions\n,\n \ndesign_region\n,\n \nbasis\n\n\n\ndefining your objective function, the objective regions on which \nits inputs (the objective variables) are defined, the design region,\nand an expansion basis.\n\n\n\n\ncreate_sim\n: Instantiation of design-dependent geometries\nInputs a vector of expansion coefficients \nbeta_vector\n and \nreturns a \nmeep.simulation\n describing a geometry with the \ncorresponding spatially-varying permittivity.\n\n\n\n\n\n\nYou run computations on your geometry either by executing your\n   script from the shell with command-line options:\n\n\n\n\n  % python HoleyWaveguide.py --beta \n0\n \n2\n.3 --eval_gradient\n\n\n\n\nor equivalently from a python script or console by \ncalling its \nrun()\n method:\n\n\n  \nfrom\n \nHoleyWaveguide\n \nimport\n \nHoleyWaveguide\n\n\n  \nHW\n=\nHoleyWaveguide\n(\ncmdline\n=\n--beta 0 2.3 --eval_gradient\n)\n\n  \nHW\n.\nrun\n()\n\n\n\n\n\nThe actual calculations that may be run in this way\nrange from a single non-iterative computation of the objective\nfunction and (optionally) its gradient at a given set of design-variable\nvalues, to \nfull-blown iterative design optimization\n\n\nHere, in their entirety, are the python scripts implementing the 4 examples\ndescribed above. (These may also be found in the \npython/examples/adjoint_optimization\n\nsubdirectory of your \nmeep\n installation.)\n\n\nHoleyWaveguide.py\nimport\n \nsys\n\n\nimport\n \nargparse\n\n\nimport\n \nnumpy\n \nas\n \nnp\n\n\nimport\n \nmeep\n \nas\n \nmp\n\n\n\nfrom\n \nmeep.adjoint\n \nimport\n \n(\nOptimizationProblem\n,\n \nDFTCell\n,\n \nadjoint_options\n,\n\n                          \nxHat\n,\n \nyHat\n,\n \nzHat\n,\n \norigin\n,\n \nFluxLine\n,\n\n                          \nParameterizedDielectric\n,\n \nFourierLegendreBasis\n)\n\n\n\n##################################################\n\n\n##################################################\n\n\n##################################################\n\n\nclass\n \nHoleyWaveguide\n(\nOptimizationProblem\n):\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \nadd_args\n(\nself\n,\n \nparser\n):\n\n\n        \n# add new problem-specific arguments\n\n        \nparser\n.\nadd_argument\n(\n--dair\n,\n        \ntype\n=\nfloat\n,\n \ndefault\n=-\n1.0\n,\n \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--w_wvg\n,\n       \ntype\n=\nfloat\n,\n \ndefault\n=\n3.0\n,\n  \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--eps_wvg\n,\n     \ntype\n=\nfloat\n,\n \ndefault\n=\n6.0\n,\n  \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--r_disc\n,\n      \ntype\n=\nfloat\n,\n \ndefault\n=\n0.5\n,\n  \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--nr_max\n,\n      \ntype\n=\nint\n,\n   \ndefault\n=\n0\n,\n    \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--kphi_max\n,\n    \ntype\n=\nint\n,\n   \ndefault\n=\n0\n,\n    \nhelp\n=\n)\n\n\n        \n# set problem-specific defaults for existing (general) arguments\n\n        \nparser\n.\nset_defaults\n(\nfcen\n=\n0.5\n)\n\n        \nparser\n.\nset_defaults\n(\ndf\n=\n0.2\n)\n\n        \nparser\n.\nset_defaults\n(\ndpml\n=\n1.0\n)\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \ninit_problem\n(\nself\n,\n \nargs\n):\n\n\n        \n#----------------------------------------\n\n        \n# size of computational cell\n\n        \n#----------------------------------------\n\n        \nlcen\n       \n=\n \n1.0\n/\nargs\n.\nfcen\n\n        \ndpml\n       \n=\n \n0.5\n*\nlcen\n \nif\n \nargs\n.\ndpml\n==-\n1.0\n \nelse\n \nargs\n.\ndpml\n\n        \ndair\n       \n=\n \n0.5\n*\nargs\n.\nw_wvg\n \nif\n \nargs\n.\ndair\n==-\n1.0\n \nelse\n \nargs\n.\ndair\n\n        \nL\n          \n=\n \n3.0\n*\nlcen\n\n        \nLmin\n       \n=\n \n6.0\n*\ndpml\n \n+\n \n2.0\n*\nargs\n.\nr_disc\n\n        \nL\n          \n=\n \nmax\n(\nL\n,\nLmin\n)\n\n        \nsx\n         \n=\n \ndpml\n+\nL\n+\ndpml\n\n        \nsy\n         \n=\n \ndpml\n+\ndair\n+\nargs\n.\nw_wvg\n+\ndair\n+\ndpml\n\n        \ncell_size\n  \n=\n \nmp\n.\nVector3\n(\nsx\n,\nsy\n)\n\n\n        \n#----------------------------------------\n\n        \n#- design region\n\n        \n#----------------------------------------\n\n        \ndesign_center\n \n=\n \norigin\n\n        \ndesign_size\n   \n=\n \nmp\n.\nVector3\n(\n2.0\n*\nargs\n.\nr_disc\n,\n \n2.0\n*\nargs\n.\nr_disc\n)\n\n        \ndesign_region\n \n=\n \nmp\n.\nVolume\n(\ncenter\n=\ndesign_center\n,\n \nsize\n=\ndesign_size\n)\n\n\n        \n#----------------------------------------\n\n        \n#- objective regions\n\n        \n#----------------------------------------\n\n        \nx0_east\n       \n=\n  \nargs\n.\nr_disc\n \n+\n \ndpml\n\n        \nx0_west\n       \n=\n \n-\nargs\n.\nr_disc\n \n-\n \ndpml\n\n        \ny0\n            \n=\n \n0.0\n\n        \nflux_length\n   \n=\n \n2.0\n*\nargs\n.\nw_wvg\n\n        \neast\n          \n=\n \nFluxLine\n(\nx0_east\n,\ny0\n,\nflux_length\n,\nmp\n.\nX\n,\neast\n)\n\n        \nwest\n          \n=\n \nFluxLine\n(\nx0_west\n,\ny0\n,\nflux_length\n,\nmp\n.\nX\n,\nwest\n)\n\n\n        \nobjective_regions\n  \n=\n \n[\neast\n,\n \nwest\n]\n\n\n        \n#----------------------------------------\n\n        \n#- optional extra regions for visualization\n\n        \n#----------------------------------------\n\n        \nextra_regions\n      \n=\n \n[\nmp\n.\nVolume\n(\ncenter\n=\norigin\n,\n \nsize\n=\ncell_size\n)]\n \nif\n \nargs\n.\nfull_dfts\n \nelse\n \n[]\n\n\n        \n#----------------------------------------\n\n        \n# basis set\n\n        \n#----------------------------------------\n\n        \nbasis\n \n=\n \nFourierLegendreBasis\n(\nradius\n=\nargs\n.\nr_disc\n,\n \nnr_max\n=\nargs\n.\nnr_max\n,\n \nkphi_max\n=\nargs\n.\nkphi_max\n)\n\n\n        \n#----------------------------------------\n\n        \n#- source location\n\n        \n#----------------------------------------\n\n        \nsource_center\n    \n=\n \n(\nx0_west\n \n-\n \ndpml\n)\n*\nxHat\n\n        \nsource_size\n      \n=\n \nflux_length\n*\nyHat\n\n\n        \n#----------------------------------------\n\n        \n#- objective function\n\n        \n#----------------------------------------\n\n        \nfstr\n=\nAbs(P1_east)**2+0.0*(P2_east+P1_west+P2_west+M1_east+M2_east+M1_west+M2_west+S_east+S_west)\n\n\n        \n#----------------------------------------\n\n        \n#- internal storage for variables needed later\n\n        \n#----------------------------------------\n\n        \nself\n.\nargs\n            \n=\n \nargs\n\n        \nself\n.\ndpml\n            \n=\n \ndpml\n\n        \nself\n.\ncell_size\n       \n=\n \ncell_size\n\n        \nself\n.\nbasis\n           \n=\n \nbasis\n\n        \nself\n.\ndesign_center\n   \n=\n \ndesign_center\n\n        \nself\n.\nsource_center\n   \n=\n \nsource_center\n\n        \nself\n.\nsource_size\n     \n=\n \nsource_size\n\n\n        \nreturn\n \nfstr\n,\n \nobjective_regions\n,\n \nextra_regions\n,\n \ndesign_region\n,\n \nbasis\n\n\n    \n##############################################################\n\n    \n##############################################################\n\n    \n##############################################################\n\n    \ndef\n \ncreate_sim\n(\nself\n,\n \nbeta_vector\n,\n \nvacuum\n=\nFalse\n):\n\n\n        \nargs\n=\nself\n.\nargs\n\n        \nsx\n=\nself\n.\ncell_size\n.\nx\n\n\n        \nwvg\n=\nmp\n.\nBlock\n(\ncenter\n=\norigin\n,\n \nmaterial\n=\nmp\n.\nMedium\n(\nepsilon\n=\nargs\n.\neps_wvg\n),\n\n                     \nsize\n=\nmp\n.\nVector3\n(\nself\n.\ncell_size\n.\nx\n,\nargs\n.\nw_wvg\n))\n\n        \ndisc\n=\nmp\n.\nCylinder\n(\ncenter\n=\nself\n.\ndesign_center\n,\n \nradius\n=\nargs\n.\nr_disc\n,\n\n                         \nepsilon_func\n=\nParameterizedDielectric\n(\nself\n.\ndesign_center\n,\n\n                                                              \nself\n.\nbasis\n,\n\n                                                              \nbeta_vector\n))\n\n\n        \ngeometry\n=\n[\nwvg\n]\n \nif\n \nvacuum\n \nelse\n \n[\nwvg\n,\n \ndisc\n]\n\n\n        \nenvelope\n \n=\n \nmp\n.\nGaussianSource\n(\nargs\n.\nfcen\n,\nfwidth\n=\nargs\n.\ndf\n)\n\n        \namp\n=\n1.0\n\n        \nif\n \ncallable\n(\ngetattr\n(\nenvelope\n,\n \nfourier_transform\n,\n \nNone\n)):\n\n            \namp\n \n/=\n \nenvelope\n.\nfourier_transform\n(\nargs\n.\nfcen\n)\n\n        \nsources\n=\n[\nmp\n.\nEigenModeSource\n(\nsrc\n=\nenvelope\n,\n\n                                    \ncenter\n=\nself\n.\nsource_center\n,\n\n                                    \nsize\n=\nself\n.\nsource_size\n,\n\n                                    \neig_band\n=\nself\n.\nargs\n.\nsource_mode\n,\n\n                                    \namplitude\n=\namp\n\n                                   \n)\n\n                \n]\n\n\n        \nsim\n=\nmp\n.\nSimulation\n(\nresolution\n=\nargs\n.\nres\n,\n \ncell_size\n=\nself\n.\ncell_size\n,\n\n                          \nboundary_layers\n=\n[\nmp\n.\nPML\n(\nargs\n.\ndpml\n)],\n \ngeometry\n=\ngeometry\n,\n\n                          \nsources\n=\nsources\n)\n\n\n        \nif\n \nargs\n.\ncomplex_fields\n:\n\n            \nsim\n.\nforce_complex_fields\n=\nTrue\n\n\n        \nreturn\n \nsim\n\n\n\n######################################################################\n\n\n# if executed as a script, we look at our own filename to figure out\n\n\n# the name of the class above, create an instance of this class called\n\n\n# opt_prob, and call its run() method.\n\n\n######################################################################\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \nopt_prob\n=\nglobals\n()[\n__file__\n.\nsplit\n(\n/\n)[\n-\n1\n]\n.\nsplit\n(\n.\n)[\n0\n]]()\n\n    \nopt_prob\n.\nrun\n()\n\n\n\n\n\n\n\n\n\n\n\nHoleCloak.py\n\n\nimport\n \nsys\n\n\nimport\n \nargparse\n\n\nimport\n \nnumpy\n \nas\n \nnp\n\n\nimport\n \nmeep\n \nas\n \nmp\n\n\n\nfrom\n \nmeep.adjoint\n \nimport\n \n(\nOptimizationProblem\n,\n \nDFTCell\n,\n \nadjoint_options\n,\n\n                          \nxHat\n,\n \nyHat\n,\n \nzHat\n,\n \norigin\n,\n \nFluxLine\n,\n\n                          \nParameterizedDielectric\n,\n \nFourierLegendreBasis\n)\n\n\n\n##################################################\n\n\n##################################################\n\n\n##################################################\n\n\nclass\n \nHoleCloak\n(\nOptimizationProblem\n):\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \nadd_args\n(\nself\n,\n \nparser\n):\n\n\n        \n# add new problem-specific arguments\n\n        \nparser\n.\nadd_argument\n(\n--dair\n,\n        \ntype\n=\nfloat\n,\n \ndefault\n=-\n1.0\n,\n \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--w_wvg\n,\n       \ntype\n=\nfloat\n,\n \ndefault\n=\n4.0\n,\n  \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--eps_wvg\n,\n     \ntype\n=\nfloat\n,\n \ndefault\n=\n6.0\n,\n  \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--r_disc\n,\n      \ntype\n=\nfloat\n,\n \ndefault\n=\n0.5\n,\n  \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--r_cloak\n,\n     \ntype\n=\nfloat\n,\n \ndefault\n=\n1.5\n,\n  \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--nr_max\n,\n      \ntype\n=\nint\n,\n   \ndefault\n=\n3\n,\n    \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--kphi_max\n,\n    \ntype\n=\nint\n,\n   \ndefault\n=\n2\n,\n    \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--eps_disc\n,\n    \ntype\n=\nfloat\n,\n \ndefault\n=\n1.0\n,\n  \nhelp\n=\npermittivity in hole region (0.0 for PEC)\n)\n\n\n        \n# set problem-specific defaults for existing (general) arguments\n\n        \nparser\n.\nset_defaults\n(\nfcen\n=\n0.5\n)\n\n        \nparser\n.\nset_defaults\n(\ndf\n=\n0.2\n)\n\n        \nparser\n.\nset_defaults\n(\ndpml\n=\n1.0\n)\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \ninit_problem\n(\nself\n,\n \nargs\n):\n\n\n        \n#----------------------------------------\n\n        \n# size of computational cell\n\n        \n#----------------------------------------\n\n        \nlcen\n       \n=\n \n1.0\n/\nargs\n.\nfcen\n\n        \ndpml\n       \n=\n \n0.5\n*\nlcen\n \nif\n \nargs\n.\ndpml\n==-\n1.0\n \nelse\n \nargs\n.\ndpml\n\n        \ndair\n       \n=\n \n0.5\n*\nargs\n.\nw_wvg\n \nif\n \nargs\n.\ndair\n==-\n1.0\n \nelse\n \nargs\n.\ndair\n\n        \nL\n          \n=\n \n3.0\n*\nlcen\n\n        \nLmin\n       \n=\n \n6.0\n*\ndpml\n \n+\n \n2.0\n*\nargs\n.\nr_cloak\n\n        \nL\n          \n=\n \nmax\n(\nL\n,\nLmin\n)\n\n        \nsx\n         \n=\n \ndpml\n+\nL\n+\ndpml\n\n        \nsy\n         \n=\n \ndpml\n+\ndair\n+\nargs\n.\nw_wvg\n+\ndair\n+\ndpml\n\n        \ncell_size\n  \n=\n \nmp\n.\nVector3\n(\nsx\n,\n \nsy\n,\n \n0.0\n)\n\n\n        \n#----------------------------------------\n\n        \n#- design region\n\n        \n#----------------------------------------\n\n        \ndesign_center\n \n=\n \norigin\n\n        \ndesign_size\n   \n=\n \nmp\n.\nVector3\n(\n2.0\n*\nargs\n.\nr_cloak\n,\n \n2.0\n*\nargs\n.\nr_cloak\n)\n\n        \ndesign_region\n \n=\n \nmp\n.\nVolume\n(\ncenter\n=\ndesign_center\n,\n \nsize\n=\ndesign_size\n)\n\n\n        \n#----------------------------------------\n\n        \n#- objective regions\n\n        \n#----------------------------------------\n\n        \nfluxW_center\n  \n=\n  \n(\n+\nargs\n.\nr_cloak\n+\n \ndpml\n)\n*\nxHat\n\n        \nfluxE_center\n  \n=\n  \n(\n-\nargs\n.\nr_cloak\n-\n \ndpml\n)\n*\nxHat\n\n        \nflux_size\n     \n=\n  \n2.0\n*\nargs\n.\nw_wvg\n*\nyHat\n\n\n        \n#fluxW_region  = mp.FluxRegion(center=fluxW_center, size=flux_size, direction=mp.X)\n\n        \n#fluxE_region  = mp.FluxRegion(center=fluxE_center, size=flux_size, direction=mp.X)\n\n        \nx0_east\n       \n=\n  \nargs\n.\nr_cloak\n \n+\n \ndpml\n\n        \nx0_west\n       \n=\n \n-\nargs\n.\nr_cloak\n \n-\n \ndpml\n\n        \ny0\n            \n=\n \n0.0\n\n        \nflux_length\n   \n=\n \n2.0\n*\nargs\n.\nw_wvg\n\n        \neast\n          \n=\n \nFluxLine\n(\nx0_east\n,\ny0\n,\nflux_length\n,\nmp\n.\nX\n,\neast\n)\n\n        \nwest\n          \n=\n \nFluxLine\n(\nx0_west\n,\ny0\n,\nflux_length\n,\nmp\n.\nX\n,\nwest\n)\n\n\n        \nobjective_regions\n  \n=\n \n[\neast\n,\n \nwest\n]\n\n\n        \n#----------------------------------------\n\n        \n#- optional extra regions for visualization\n\n        \n#----------------------------------------\n\n        \nextra_regions\n      \n=\n \n[\nmp\n.\nVolume\n(\ncenter\n=\norigin\n,\n \nsize\n=\ncell_size\n)]\n \nif\n \nargs\n.\nfull_dfts\n \nelse\n \n[]\n\n\n        \n#----------------------------------------\n\n        \n# basis set\n\n        \n#----------------------------------------\n\n        \nbasis\n \n=\n \nFourierLegendreBasis\n(\nouter_radius\n=\nargs\n.\nr_cloak\n,\n \ninner_radius\n=\nargs\n.\nr_disc\n,\n\n                                     \nnr_max\n=\nargs\n.\nnr_max\n,\n \nkphi_max\n=\nargs\n.\nkphi_max\n)\n\n\n        \n#----------------------------------------\n\n        \n#- source location\n\n        \n#----------------------------------------\n\n        \nsource_center\n    \n=\n \n(\nx0_west\n-\ndpml\n)\n*\nxHat\n\n        \nsource_size\n      \n=\n \nflux_length\n*\nyHat\n\n\n        \n#----------------------------------------\n\n        \n#- objective function\n\n        \n#----------------------------------------\n\n        \nfstr\n=\nAbs(P1_east)**2+0.0*(P1_west + M1_east + M1_west + S_west + S_east)\n\n\n        \n#----------------------------------------\n\n        \n#- internal storage for variables needed later\n\n        \n#----------------------------------------\n\n        \nself\n.\nargs\n            \n=\n \nargs\n\n        \nself\n.\ndpml\n            \n=\n \ndpml\n\n        \nself\n.\ncell_size\n       \n=\n \ncell_size\n\n        \nself\n.\nbasis\n           \n=\n \nbasis\n\n        \nself\n.\ndesign_center\n   \n=\n \ndesign_center\n\n        \nself\n.\nsource_center\n   \n=\n \nsource_center\n\n        \nself\n.\nsource_size\n     \n=\n \nsource_size\n\n\n        \nreturn\n \nfstr\n,\n \nobjective_regions\n,\n \nextra_regions\n,\n \ndesign_region\n,\n \nbasis\n\n\n    \n##############################################################\n\n    \n##############################################################\n\n    \n##############################################################\n\n    \ndef\n \ncreate_sim\n(\nself\n,\n \nbeta_vector\n,\n \nvacuum\n=\nFalse\n):\n\n\n        \nargs\n=\nself\n.\nargs\n\n        \nsx\n=\nself\n.\ncell_size\n.\nx\n\n\n        \nwvg\n=\nmp\n.\nBlock\n(\ncenter\n=\norigin\n,\n \nmaterial\n=\nmp\n.\nMedium\n(\nepsilon\n=\nargs\n.\neps_wvg\n),\n\n                     \nsize\n=\nmp\n.\nVector3\n(\nself\n.\ncell_size\n.\nx\n,\nargs\n.\nw_wvg\n))\n\n        \ncloak\n=\nmp\n.\nCylinder\n(\ncenter\n=\nself\n.\ndesign_center\n,\n \nradius\n=\nargs\n.\nr_cloak\n,\n\n                          \nepsilon_func\n=\nParameterizedDielectric\n(\nself\n.\ndesign_center\n,\n\n                                                               \nself\n.\nbasis\n,\n\n                                                               \nbeta_vector\n))\n\n        \ndisc\n=\nmp\n.\nCylinder\n(\ncenter\n=\nself\n.\ndesign_center\n,\n \nradius\n=\nargs\n.\nr_disc\n,\n\n                         \nmaterial\n=\n(\nmp\n.\nmetal\n \nif\n \nargs\n.\neps_disc\n==\n0\n \nelse\n\n                                   \nmp\n.\nMedium\n(\nepsilon\n=\nargs\n.\neps_disc\n)))\n\n\n        \ngeometry\n=\n[\nwvg\n]\n \nif\n \nvacuum\n \nelse\n \n[\nwvg\n,\n \ncloak\n,\n \ndisc\n]\n\n\n        \nenvelope\n \n=\n \nmp\n.\nGaussianSource\n(\nargs\n.\nfcen\n,\nfwidth\n=\nargs\n.\ndf\n)\n\n        \namp\n=\n1.0\n\n        \nif\n \ncallable\n(\ngetattr\n(\nenvelope\n,\n \nfourier_transform\n,\n \nNone\n)):\n\n            \namp\n \n/=\n \nenvelope\n.\nfourier_transform\n(\nargs\n.\nfcen\n)\n\n        \nsources\n=\n[\nmp\n.\nEigenModeSource\n(\nsrc\n=\nenvelope\n,\n\n                                    \ncenter\n=\nself\n.\nsource_center\n,\n\n                                    \nsize\n=\nself\n.\nsource_size\n,\n\n                                    \neig_band\n=\nself\n.\nargs\n.\nsource_mode\n,\n\n                                    \namplitude\n=\namp\n\n                                   \n)\n\n                \n]\n\n\n        \nsim\n=\nmp\n.\nSimulation\n(\nresolution\n=\nargs\n.\nres\n,\n \ncell_size\n=\nself\n.\ncell_size\n,\n\n                          \nboundary_layers\n=\n[\nmp\n.\nPML\n(\nargs\n.\ndpml\n)],\n \ngeometry\n=\ngeometry\n,\n\n                          \nsources\n=\nsources\n)\n\n\n        \nif\n \nargs\n.\ncomplex_fields\n:\n\n            \nsim\n.\nforce_complex_fields\n=\nTrue\n\n\n        \nreturn\n \nsim\n\n\n\n######################################################################\n\n\n# if executed as a script, we look at our own filename to figure out\n\n\n# the name of the class above, create an instance of this class called\n\n\n# opt_prob, and call its run() method.\n\n\n######################################################################\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \nopt_prob\n=\nglobals\n()[\n__file__\n.\nsplit\n(\n/\n)[\n-\n1\n]\n.\nsplit\n(\n.\n)[\n0\n]]()\n\n    \nopt_prob\n.\nrun\n()\n\n\n\n\n\n\n\n\n\nCrossRouter.py\n\n\nimport\n \nnumpy\n \nas\n \nnp\n\n\nimport\n \nmeep\n \nas\n \nmp\n\n\n\nfrom\n \nmeep.adjoint\n \nimport\n \n(\nOptimizationProblem\n,\n \nFluxLine\n,\n\n                          \nxHat\n,\n \nyHat\n,\n \nzHat\n,\n \norigin\n,\n\n                          \nParameterizedDielectric\n,\n \nFiniteElementBasis\n)\n\n\n\n##################################################\n\n\n##################################################\n\n\n##################################################\n\n\nclass\n \nCrossRouter\n(\nOptimizationProblem\n):\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \nadd_args\n(\nself\n,\n \nparser\n):\n\n\n        \n# add new problem-specific arguments\n\n        \nparser\n.\nadd_argument\n(\n--wh\n,\n       \ntype\n=\nfloat\n,\n \ndefault\n=\n1.5\n,\n  \nhelp\n=\nwidth of horizontal waveguide\n)\n\n        \nparser\n.\nadd_argument\n(\n--wv\n,\n       \ntype\n=\nfloat\n,\n \ndefault\n=\n1.5\n,\n  \nhelp\n=\nwidth of vertical waveguide\n)\n\n        \nparser\n.\nadd_argument\n(\n--l_stub\n,\n   \ntype\n=\nfloat\n,\n \ndefault\n=\n3.0\n,\n  \nhelp\n=\nwaveguide input/output stub length\n)\n\n        \nparser\n.\nadd_argument\n(\n--eps\n,\n      \ntype\n=\nfloat\n,\n \ndefault\n=\n6.0\n,\n  \nhelp\n=\nwaveguide permittivity\n)\n\n        \nparser\n.\nadd_argument\n(\n--r_design\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n0.0\n,\n  \nhelp\n=\ndesign region radius\n)\n\n        \nparser\n.\nadd_argument\n(\n--l_design\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n4.0\n,\n  \nhelp\n=\ndesign region side length\n)\n\n        \nparser\n.\nadd_argument\n(\n--nfe\n,\n      \ntype\n=\nint\n,\n   \ndefault\n=\n2\n,\n    \nhelp\n=\nnumber of finite elements per unit length\n)\n\n        \nparser\n.\nadd_argument\n(\n--n_weight\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n1.00\n,\n \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--s_weight\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n0.00\n,\n \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--e_weight\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n0.00\n,\n \nhelp\n=\n)\n\n\n        \n# set problem-specific defaults for existing (general) arguments\n\n        \nparser\n.\nset_defaults\n(\nfcen\n=\n0.5\n)\n\n        \nparser\n.\nset_defaults\n(\ndf\n=\n0.2\n)\n\n        \nparser\n.\nset_defaults\n(\ndpml\n=\n1.0\n)\n\n        \nparser\n.\nset_defaults\n(\nepsilon_design\n=\n6.0\n)\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \ninit_problem\n(\nself\n,\n \nargs\n):\n\n\n        \n#----------------------------------------\n\n        \n# size of computational cell\n\n        \n#----------------------------------------\n\n        \nlcen\n          \n=\n \n1.0\n/\nargs\n.\nfcen\n\n        \ndpml\n          \n=\n \n0.5\n*\nlcen\n \nif\n \nargs\n.\ndpml\n \n==\n \n-\n1.0\n \nelse\n \nargs\n.\ndpml\n\n        \ndesign_length\n \n=\n \n2.0\n*\nargs\n.\nr_design\n \nif\n \nargs\n.\nr_design\n \n \n0.0\n \nelse\n \nargs\n.\nl_design\n\n        \nsx\n \n=\n \nsy\n       \n=\n \ndpml\n \n+\n \nargs\n.\nl_stub\n \n+\n \ndesign_length\n \n+\n \nargs\n.\nl_stub\n \n+\n \ndpml\n\n        \ncell_size\n     \n=\n \nmp\n.\nVector3\n(\nsx\n,\n \nsy\n,\n \n0.0\n)\n\n\n        \n#----------------------------------------\n\n        \n#- design region bounding box\n\n        \n#----------------------------------------\n\n        \ndesign_center\n \n=\n \norigin\n\n        \ndesign_size\n   \n=\n \nmp\n.\nVector3\n(\ndesign_length\n,\n \ndesign_length\n)\n\n        \ndesign_region\n \n=\n \nmp\n.\nVolume\n(\ncenter\n=\ndesign_center\n,\n \nsize\n=\ndesign_size\n)\n\n\n        \n#----------------------------------------\n\n        \n#- objective and source regions\n\n        \n#----------------------------------------\n\n        \ngap\n            \n=\n  \nargs\n.\nl_stub\n/\n6.0\n                    \n# gap between source region and flux monitor\n\n        \nd_flux\n         \n=\n  \n0.5\n*\n(\ndesign_length\n \n+\n \nargs\n.\nl_stub\n)\n  \n# distance from origin to NSEW flux monitors\n\n        \nd_source\n       \n=\n  \nd_flux\n \n+\n \ngap\n                       \n# distance from origin to source\n\n        \nd_flx2\n         \n=\n  \nd_flux\n \n+\n \n2.0\n*\ngap\n\n        \nl_flux_NS\n      \n=\n  \n2.0\n*\nargs\n.\nwv\n\n        \nl_flux_EW\n      \n=\n  \n2.0\n*\nargs\n.\nwh\n\n        \nnorth\n          \n=\n  \nFluxLine\n(\n0.0\n,\n \n+\nd_flux\n,\n \nl_flux_NS\n,\n \nmp\n.\nY\n,\n \nnorth\n)\n\n        \nsouth\n          \n=\n  \nFluxLine\n(\n0.0\n,\n \n-\nd_flux\n,\n \nl_flux_NS\n,\n \nmp\n.\nY\n,\n \nsouth\n)\n\n        \neast\n           \n=\n  \nFluxLine\n(\n+\nd_flux\n,\n \n0.0\n,\n \nl_flux_EW\n,\n \nmp\n.\nX\n,\n \neast\n)\n\n        \nwest1\n          \n=\n  \nFluxLine\n(\n-\nd_flux\n,\n \n0.0\n,\n \nl_flux_EW\n,\n \nmp\n.\nX\n,\n \nwest1\n)\n\n        \nwest2\n          \n=\n  \nFluxLine\n(\n-\nd_flx2\n,\n \n0.0\n,\n \nl_flux_EW\n,\n \nmp\n.\nX\n,\n \nwest2\n)\n\n\n        \nobjective_regions\n  \n=\n \n[\nnorth\n,\n \nsouth\n,\n \neast\n,\n \nwest1\n,\n \nwest2\n]\n\n\n        \nsource_center\n  \n=\n  \nmp\n.\nVector3\n(\n-\nd_source\n,\n \n0.0\n)\n\n        \nsource_size\n    \n=\n  \nmp\n.\nVector3\n(\n0.0\n,\nl_flux_EW\n)\n\n\n        \n#----------------------------------------\n\n        \n#- optional extra regions for visualization\n\n        \n#----------------------------------------\n\n        \nextra_regions\n  \n=\n \n[\nmp\n.\nVolume\n(\ncenter\n=\norigin\n,\n \nsize\n=\ncell_size\n)]\n \nif\n \nargs\n.\nfull_dfts\n \nelse\n \n[]\n\n\n        \n#----------------------------------------\n\n        \n# basis set\n\n        \n#----------------------------------------\n\n        \nbasis\n \n=\n \nFiniteElementBasis\n(\nlx\n=\nargs\n.\nl_design\n,\n \nly\n=\nargs\n.\nl_design\n,\n \ndensity\n=\nargs\n.\nnfe\n)\n\n\n        \n#----------------------------------------\n\n        \n#- objective function\n\n        \n#----------------------------------------\n\n        \nfstr\n=\n(\n   \n   \n{:s}\n*Abs(P1_north)**2\n.\nformat\n(\n0.0\n \nif\n \nargs\n.\nn_weight\n==\n0.0\n \nelse\n \n{}\n.\nformat\n(\nargs\n.\nn_weight\n))\n\n               \n+\n \n + \n{:s}\n*Abs(M1_south)**2\n.\nformat\n(\n0.0\n \nif\n \nargs\n.\ns_weight\n==\n0.0\n \nelse\n \n{}\n.\nformat\n(\nargs\n.\ns_weight\n))\n\n               \n+\n \n + \n{:s}\n*Abs(P1_east)**2\n.\nformat\n(\n0.0\n  \nif\n \nargs\n.\ne_weight\n==\n0.0\n \nelse\n \n{}\n.\nformat\n(\nargs\n.\ne_weight\n))\n\n               \n+\n \n + 0.0*(P1_north + M1_south + P1_east + P1_west1 + P1_west2)\n\n               \n+\n \n + 0.0*(M1_north + M1_south + M1_east + M1_west1 + M1_west2)\n\n               \n+\n \n + 0.0*(S_north + S_south + S_east + S_west1 + S_west2)\n\n             \n)\n\n\n        \n#----------------------------------------\n\n        \n#- internal storage for variables needed later\n\n        \n#----------------------------------------\n\n        \nself\n.\nargs\n            \n=\n \nargs\n\n        \nself\n.\ndpml\n            \n=\n \ndpml\n\n        \nself\n.\ncell_size\n       \n=\n \ncell_size\n\n        \nself\n.\nbasis\n           \n=\n \nbasis\n\n        \nself\n.\ndesign_center\n   \n=\n \ndesign_center\n\n        \nself\n.\ndesign_size\n     \n=\n \ndesign_size\n\n        \nself\n.\nsource_center\n   \n=\n \nsource_center\n\n        \nself\n.\nsource_size\n     \n=\n \nsource_size\n\n\n        \nif\n \nargs\n.\neps_design\n \nis\n \nNone\n:\n\n            \nargs\n.\neps_design\n \n=\n \nargs\n.\neps\n\n\n        \nreturn\n \nfstr\n,\n \nobjective_regions\n,\n \nextra_regions\n,\n \ndesign_region\n,\n \nbasis\n\n\n    \n##############################################################\n\n    \n##############################################################\n\n    \n##############################################################\n\n    \ndef\n \ncreate_sim\n(\nself\n,\n \nbeta_vector\n,\n \nvacuum\n=\nFalse\n):\n\n\n        \nargs\n=\nself\n.\nargs\n\n\n        \nhwvg\n=\nmp\n.\nBlock\n(\ncenter\n=\norigin\n,\n \nmaterial\n=\nmp\n.\nMedium\n(\nepsilon\n=\nargs\n.\neps\n),\n\n                      \nsize\n=\nmp\n.\nVector3\n(\nself\n.\ncell_size\n.\nx\n,\nargs\n.\nwh\n))\n\n        \nvwvg\n=\nmp\n.\nBlock\n(\ncenter\n=\norigin\n,\n \nmaterial\n=\nmp\n.\nMedium\n(\nepsilon\n=\nargs\n.\neps\n),\n\n                      \nsize\n=\nmp\n.\nVector3\n(\nargs\n.\nwv\n,\nself\n.\ncell_size\n.\ny\n))\n\n\n        \nif\n \nargs\n.\nr_design\n0.0\n:\n\n            \nrouter\n=\nmp\n.\nCylinder\n(\ncenter\n=\nself\n.\ndesign_center\n,\n \nradius\n=\nargs\n.\nr_design\n,\n\n                               \nepsilon_func\n=\nParameterizedDielectric\n(\nself\n.\ndesign_center\n,\n\n                                                                    \nself\n.\nbasis\n,\n\n                                                                    \nbeta_vector\n))\n\n        \nelse\n:\n\n            \nrouter\n=\nmp\n.\nBlock\n(\ncenter\n=\nself\n.\ndesign_center\n,\n \nsize\n=\nself\n.\ndesign_size\n,\n\n                            \nepsilon_func\n=\nParameterizedDielectric\n(\nself\n.\ndesign_center\n,\n\n                                                                 \nself\n.\nbasis\n,\n\n                                                                 \nbeta_vector\n))\n\n        \ngeometry\n=\n[\nhwvg\n,\n \nvwvg\n,\n \nrouter\n]\n\n\n        \nenvelope\n \n=\n \nmp\n.\nGaussianSource\n(\nargs\n.\nfcen\n,\nfwidth\n=\nargs\n.\ndf\n)\n\n        \namp\n=\n1.0\n\n        \nif\n \ncallable\n(\ngetattr\n(\nenvelope\n,\n \nfourier_transform\n,\n \nNone\n)):\n\n            \namp\n \n/=\n \nenvelope\n.\nfourier_transform\n(\nargs\n.\nfcen\n)\n\n        \nsources\n=\n[\nmp\n.\nEigenModeSource\n(\nsrc\n=\nenvelope\n,\n\n                                    \ncenter\n=\nself\n.\nsource_center\n,\n\n                                    \nsize\n=\nself\n.\nsource_size\n,\n\n                                    \neig_band\n=\nargs\n.\nsource_mode\n,\n\n                                    \namplitude\n=\namp\n\n                                   \n)\n\n                \n]\n\n\n        \nsim\n=\nmp\n.\nSimulation\n(\nresolution\n=\nargs\n.\nres\n,\n \ncell_size\n=\nself\n.\ncell_size\n,\n\n                          \nboundary_layers\n=\n[\nmp\n.\nPML\n(\nself\n.\ndpml\n)],\n \ngeometry\n=\ngeometry\n,\n\n                          \nsources\n=\nsources\n)\n\n\n        \nif\n \nargs\n.\ncomplex_fields\n:\n\n            \nsim\n.\nforce_complex_fields\n=\nTrue\n\n\n        \nreturn\n \nsim\n\n\n\n######################################################################\n\n\n# if executed as a script, we look at our own filename to figure out\n\n\n# the name of the class above, create an instance of this class called\n\n\n# op, and call its run() method.\n\n\n######################################################################\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \nop\n=\nglobals\n()[\n__file__\n.\nsplit\n(\n/\n)[\n-\n1\n]\n.\nsplit\n(\n.\n)[\n0\n]]()\n\n    \nop\n.\nrun\n()\n\n\n\n\n\n\n\n\n\nAsmmetricSplitter.py\n\n\n\n\nimport\n \nnumpy\n \nas\n \nnp\n\n\nimport\n \nmeep\n \nas\n \nmp\n\n\n\nfrom\n \nmeep.adjoint\n \nimport\n \n(\nOptimizationProblem\n,\n \nFluxLine\n,\n\n                          \nxHat\n,\n \nyHat\n,\n \nzHat\n,\n \norigin\n,\n\n                          \nParameterizedDielectric\n,\n \nFiniteElementBasis\n)\n\n\n\n##################################################\n\n\n##################################################\n\n\n##################################################\n\n\nclass\n \nCrossRouter\n(\nOptimizationProblem\n):\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \nadd_args\n(\nself\n,\n \nparser\n):\n\n\n        \n# add new problem-specific arguments\n\n        \nparser\n.\nadd_argument\n(\n--wh\n,\n       \ntype\n=\nfloat\n,\n \ndefault\n=\n1.5\n,\n  \nhelp\n=\nwidth of horizontal waveguide\n)\n\n        \nparser\n.\nadd_argument\n(\n--wv\n,\n       \ntype\n=\nfloat\n,\n \ndefault\n=\n1.5\n,\n  \nhelp\n=\nwidth of vertical waveguide\n)\n\n        \nparser\n.\nadd_argument\n(\n--l_stub\n,\n   \ntype\n=\nfloat\n,\n \ndefault\n=\n3.0\n,\n  \nhelp\n=\nwaveguide input/output stub length\n)\n\n        \nparser\n.\nadd_argument\n(\n--eps\n,\n      \ntype\n=\nfloat\n,\n \ndefault\n=\n6.0\n,\n  \nhelp\n=\nwaveguide permittivity\n)\n\n        \nparser\n.\nadd_argument\n(\n--r_design\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n0.0\n,\n  \nhelp\n=\ndesign region radius\n)\n\n        \nparser\n.\nadd_argument\n(\n--l_design\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n4.0\n,\n  \nhelp\n=\ndesign region side length\n)\n\n        \nparser\n.\nadd_argument\n(\n--nfe\n,\n      \ntype\n=\nint\n,\n   \ndefault\n=\n2\n,\n    \nhelp\n=\nnumber of finite elements per unit length\n)\n\n        \nparser\n.\nadd_argument\n(\n--n_weight\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n1.00\n,\n \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--s_weight\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n0.00\n,\n \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--e_weight\n,\n \ntype\n=\nfloat\n,\n \ndefault\n=\n0.00\n,\n \nhelp\n=\n)\n\n\n        \n# set problem-specific defaults for existing (general) arguments\n\n        \nparser\n.\nset_defaults\n(\nfcen\n=\n0.5\n)\n\n        \nparser\n.\nset_defaults\n(\ndf\n=\n0.2\n)\n\n        \nparser\n.\nset_defaults\n(\ndpml\n=\n1.0\n)\n\n        \nparser\n.\nset_defaults\n(\nepsilon_design\n=\n6.0\n)\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \ninit_problem\n(\nself\n,\n \nargs\n):\n\n\n\n\n\n```\npy3\n\n\nimport\n \nsys\n\n\nimport\n \nargparse\n\n\nimport\n \nnumpy\n \nas\n \nnp\n\n\nimport\n \nmeep\n \nas\n \nmp\n\n\n\nfrom\n \nmeep.adjoint\n \nimport\n \n(\nOptimizationProblem\n,\n \nDFTCell\n,\n \nadjoint_options\n,\n\n                          \nxHat\n,\n \nyHat\n,\n \nzHat\n,\n \norigin\n,\n \nFluxLine\n,\n\n                          \nParameterizedDielectric\n,\n \nFiniteElementBasis\n)\n\n\n\n##################################################\n\n\n##################################################\n\n\n##################################################\n\n\nclass\n \nAsymmetricSplitter\n(\nOptimizationProblem\n):\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \nadd_args\n(\nself\n,\n \nparser\n):\n\n\n        \n# add new problem-specific arguments\n\n        \nparser\n.\nadd_argument\n(\n--dair\n,\n        \ntype\n=\nfloat\n,\n \ndefault\n=-\n1.0\n,\n \nhelp\n=\n)\n\n        \nparser\n.\nadd_argument\n(\n--w_in\n,\n        \ntype\n=\nfloat\n,\n \ndefault\n=\n1.0\n,\n  \nhelp\n=\nwidth of input waveguide\n)\n\n        \nparser\n.\nadd_argument\n(\n--w_out1\n,\n      \ntype\n=\nfloat\n,\n \ndefault\n=\n0.5\n,\n  \nhelp\n=\nwidth of output waveguide 1\n)\n\n        \nparser\n.\nadd_argument\n(\n--w_out2\n,\n      \ntype\n=\nfloat\n,\n \ndefault\n=\n0.5\n,\n  \nhelp\n=\nwidth of output waveguide 2\n)\n\n        \nparser\n.\nadd_argument\n(\n--l_stub\n,\n      \ntype\n=\nfloat\n,\n \ndefault\n=\n3.0\n,\n  \nhelp\n=\nlength of waveguide input/output stub\n)\n\n        \nparser\n.\nadd_argument\n(\n--l_design\n,\n    \ntype\n=\nfloat\n,\n \ndefault\n=\n2.0\n,\n  \nhelp\n=\nlength of design region\n)\n\n        \nparser\n.\nadd_argument\n(\n--h_design\n,\n    \ntype\n=\nfloat\n,\n \ndefault\n=\n6.0\n,\n  \nhelp\n=\nheight of design region\n)\n\n        \nparser\n.\nadd_argument\n(\n--eps_in\n,\n      \ntype\n=\nfloat\n,\n \ndefault\n=\n6.0\n,\n  \nhelp\n=\ninput waveguide permittivity\n)\n\n        \nparser\n.\nadd_argument\n(\n--eps_out1\n,\n    \ntype\n=\nfloat\n,\n \ndefault\n=\n2.0\n,\n  \nhelp\n=\noutput waveguide 1 permittivity\n)\n\n        \nparser\n.\nadd_argument\n(\n--eps_out2\n,\n    \ntype\n=\nfloat\n,\n \ndefault\n=\n12.0\n,\n \nhelp\n=\noutput waveguide 2 permittivity\n)\n\n        \nparser\n.\nadd_argument\n(\n--nfe\n,\n         \ntype\n=\nint\n,\n   \ndefault\n=\n2\n,\n    \nhelp\n=\nnumber of finite elements per unit length\n)\n\n\n        \n# set problem-specific defaults for existing (general) arguments\n\n        \nparser\n.\nset_defaults\n(\nfcen\n=\n0.5\n)\n\n        \nparser\n.\nset_defaults\n(\ndf\n=\n0.2\n)\n\n        \nparser\n.\nset_defaults\n(\ndpml\n=\n1.0\n)\n\n\n    \n##################################################\n\n    \n##################################################\n\n    \n##################################################\n\n    \ndef\n \ninit_problem\n(\nself\n,\n \nargs\n):\n\n\n        \n#----------------------------------------\n\n        \n# size of computational cell\n\n        \n#----------------------------------------\n\n        \nlcen\n       \n=\n \n1.0\n/\nargs\n.\nfcen\n\n        \ndpml\n       \n=\n \n0.5\n*\nlcen\n \nif\n \nargs\n.\ndpml\n==-\n1.0\n \nelse\n \nargs\n.\ndpml\n\n        \ndair\n       \n=\n \n0.5\n*\nargs\n.\nw_in\n \nif\n \nargs\n.\ndair\n==-\n1.0\n \nelse\n \nargs\n.\ndair\n\n        \nsx\n         \n=\n \ndpml\n \n+\n \nargs\n.\nl_stub\n \n+\n \nargs\n.\nl_design\n \n+\n \nargs\n.\nl_stub\n \n+\n \ndpml\n\n        \nsy\n         \n=\n \ndpml\n \n+\n \ndair\n \n+\n \nargs\n.\nh_design\n \n+\n \ndair\n \n+\n \ndpml\n\n        \ncell_size\n  \n=\n \nmp\n.\nVector3\n(\nsx\n,\n \nsy\n,\n \n0.0\n)\n\n\n        \n#----------------------------------------\n\n        \n#- design region\n\n        \n#----------------------------------------\n\n        \ndesign_center\n \n=\n \norigin\n\n        \ndesign_size\n   \n=\n \nmp\n.\nVector3\n(\nargs\n.\nl_design\n,\n \nargs\n.\nh_design\n,\n \n0.0\n)\n\n        \ndesign_region\n \n=\n \nmp\n.\nVolume\n(\ncenter\n=\ndesign_center\n,\n \nsize\n=\ndesign_size\n)\n\n\n        \n#----------------------------------------\n\n        \n#- objective regions\n\n        \n#----------------------------------------\n\n        \nx_in\n          \n=\n  \n-\n0.5\n*\n(\nargs\n.\nl_design\n \n+\n \nargs\n.\nl_stub\n)\n\n        \nx_out\n         \n=\n  \n+\n0.5\n*\n(\nargs\n.\nl_design\n \n+\n \nargs\n.\nl_stub\n)\n\n        \ny_out1\n        \n=\n  \n+\n0.25\n*\nargs\n.\nh_design\n\n        \ny_out2\n        \n=\n  \n-\n0.25\n*\nargs\n.\nh_design\n\n\n        \nflux_in\n       \n=\n  \nFluxLine\n(\nx_in\n,\n     \n0.0\n,\n \n2.0\n*\nargs\n.\nw_in\n,\n   \nmp\n.\nX\n,\n \nin\n)\n\n        \nflux_out1\n     \n=\n  \nFluxLine\n(\nx_out\n,\n \ny_out1\n,\n \n2.0\n*\nargs\n.\nw_out1\n,\n \nmp\n.\nX\n,\n \nout1\n)\n\n        \nflux_out2\n     \n=\n  \nFluxLine\n(\nx_out\n,\n \ny_out2\n,\n \n2.0\n*\nargs\n.\nw_out2\n,\n \nmp\n.\nX\n,\n \nout2\n)\n\n\n        \nobjective_regions\n  \n=\n \n[\nflux_in\n,\n \nflux_out1\n,\n \nflux_out2\n]\n\n\n        \n#----------------------------------------\n\n        \n#- optional extra regions for visualization if the --full-dfts options is present.\n\n        \n#----------------------------------------\n\n        \nextra_regions\n      \n=\n \n[\nmp\n.\nVolume\n(\ncenter\n=\norigin\n,\n \nsize\n=\ncell_size\n)]\n \nif\n \nargs\n.\nfull_dfts\n \nelse\n \n[]\n\n\n        \n#----------------------------------------\n\n        \n# forward source region\n\n        \n#----------------------------------------\n\n        \nsource_center\n    \n=\n  \n(\nx_in\n \n-\n \n0.25\n*\nargs\n.\nl_stub\n)\n*\nxHat\n\n        \nsource_size\n      \n=\n  \n2.0\n*\nargs\n.\nw_in\n*\nyHat\n\n\n        \n#----------------------------------------\n\n        \n# basis set\n\n        \n#----------------------------------------\n\n        \nbasis\n \n=\n \nFiniteElementBasis\n(\nargs\n.\nl_design\n,\n \nargs\n.\nh_design\n,\n \nargs\n.\nnfe\n)\n\n\n        \n#----------------------------------------\n\n        \n#- objective function\n\n        \n#----------------------------------------\n\n        \nfstr\n \n=\n \n(\n   \nAbs(P1_out1)**2\n\n                 \n+\n \n+0.0*(P1_out1 + M1_out1)\n\n                 \n+\n \n+0.0*(P1_out2 + M1_out2)\n\n                 \n+\n \n+0.0*(P1_in   + M1_in + S_out1 + S_out2 + S_in)\n\n               \n)\n\n\n        \n#----------------------------------------\n\n        \n#- internal storage for variables needed later\n\n        \n#----------------------------------------\n\n        \nself\n.\nargs\n            \n=\n \nargs\n\n        \nself\n.\ndpml\n            \n=\n \ndpml\n\n        \nself\n.\ncell_size\n       \n=\n \ncell_size\n\n        \nself\n.\nbasis\n           \n=\n \nbasis\n\n        \nself\n.\ndesign_center\n   \n=\n \norigin\n\n        \nself\n.\ndesign_size\n     \n=\n \ndesign_size\n\n        \nself\n.\nsource_center\n   \n=\n \nsource_center\n\n        \nself\n.\nsource_size\n     \n=\n \nsource_size\n\n\n        \nreturn\n \nfstr\n,\n \nobjective_regions\n,\n \nextra_regions\n,\n \ndesign_region\n,\n \nbasis\n\n\n    \n##############################################################\n\n    \n##############################################################\n\n    \n##############################################################\n\n    \ndef\n \ncreate_sim\n(\nself\n,\n \nbeta_vector\n,\n \nvacuum\n=\nFalse\n):\n\n\n        \nargs\n=\nself\n.\nargs\n\n        \nsx\n=\nself\n.\ncell_size\n.\nx\n\n\n        \nx_in\n   \n=\n \n-\n0.5\n*\n(\nargs\n.\nl_design\n \n+\n \nargs\n.\nl_stub\n)\n\n        \nx_out\n  \n=\n \n+\n0.5\n*\n(\nargs\n.\nl_design\n \n+\n \nargs\n.\nl_stub\n)\n\n        \ny_out1\n \n=\n \n+\n0.25\n*\nargs\n.\nh_design\n\n        \ny_out2\n \n=\n \n-\n0.25\n*\nargs\n.\nh_design\n\n\n        \nwvg_in\n \n=\n \nmp\n.\nBlock\n(\n \ncenter\n=\nmp\n.\nVector3\n(\nx_in\n,\n0.0\n),\n\n                           \nsize\n=\nmp\n.\nVector3\n(\nargs\n.\nl_stub\n,\nargs\n.\nw_in\n),\n\n                           \nmaterial\n=\nmp\n.\nMedium\n(\nepsilon\n=\nargs\n.\neps_in\n))\n\n        \nwvg_out1\n \n=\n \nmp\n.\nBlock\n(\n \ncenter\n=\nmp\n.\nVector3\n(\nx_out\n,\ny_out1\n),\n\n                             \nsize\n=\nmp\n.\nVector3\n(\nargs\n.\nl_stub\n,\nargs\n.\nw_out1\n),\n\n                             \nmaterial\n=\nmp\n.\nMedium\n(\nepsilon\n=\nargs\n.\neps_out1\n))\n\n        \nwvg_out2\n \n=\n \nmp\n.\nBlock\n(\n \ncenter\n=\nmp\n.\nVector3\n(\nx_out\n,\ny_out2\n),\n\n                             \nsize\n=\nmp\n.\nVector3\n(\nargs\n.\nl_stub\n,\nargs\n.\nw_out2\n),\n\n                             \nmaterial\n=\nmp\n.\nMedium\n(\nepsilon\n=\nargs\n.\neps_out2\n))\n\n        \ndesign\n   \n=\n \nmp\n.\nBlock\n(\n \ncenter\n=\norigin\n,\n\n                             \nsize\n=\nmp\n.\nVector3\n(\nargs\n.\nl_design\n,\nargs\n.\nh_design\n),\n\n                             \nepsilon_func\n=\nParameterizedDielectric\n(\nself\n.\ndesign_center\n,\n\n                                                                  \nself\n.\nbasis\n,\n\n                                                                  \nbeta_vector\n)\n\n                           \n)\n\n\n        \ngeometry\n=\n[\nwvg_in\n,\n \nwvg_out1\n,\n \nwvg_out2\n,\n \ndesign\n]\n\n\n        \nenvelope\n \n=\n \nmp\n.\nGaussianSource\n(\nargs\n.\nfcen\n,\nfwidth\n=\nargs\n.\ndf\n)\n\n        \namp\n=\n1.0\n\n        \nif\n \ncallable\n(\ngetattr\n(\nenvelope\n,\n \nfourier_transform\n,\n \nNone\n)):\n\n            \namp\n \n/=\n \nenvelope\n.\nfourier_transform\n(\nargs\n.\nfcen\n)\n\n        \nsources\n=\n[\nmp\n.\nEigenModeSource\n(\nsrc\n=\nenvelope\n,\n\n                                    \ncenter\n=\nself\n.\nsource_center\n,\n\n                                    \nsize\n=\nself\n.\nsource_size\n,\n\n                                    \neig_band\n=\nself\n.\nargs\n.\nsource_mode\n,\n\n                                    \namplitude\n=\namp\n\n                                   \n)\n\n                \n]\n\n\n        \nsim\n=\nmp\n.\nSimulation\n(\nresolution\n=\nargs\n.\nres\n,\n \ncell_size\n=\nself\n.\ncell_size\n,\n\n                          \nboundary_layers\n=\n[\nmp\n.\nPML\n(\nargs\n.\ndpml\n)],\n \ngeometry\n=\ngeometry\n,\n\n                          \nsources\n=\nsources\n)\n\n\n        \nif\n \nargs\n.\ncomplex_fields\n:\n\n            \nsim\n.\nforce_complex_fields\n=\nTrue\n\n\n        \nreturn\n \nsim\n\n\n\n######################################################################\n\n\n# if executed as a script, we look at our own filename to figure out\n\n\n# the name of the class above, create an instance of this class called\n\n\n# opt_prob, and call its run() method.\n\n\n######################################################################\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \nopt_prob\n=\nglobals\n()[\n__file__\n.\nsplit\n(\n/\n)[\n-\n1\n]\n.\nsplit\n(\n.\n)[\n0\n]]()\n\n    \nopt_prob\n.\nrun\n()", 
            "title": "Overview"
        }, 
        {
            "location": "/AdjointSolver/Overview/#meepadjoint-adjoint-sensitivity-analysis-for-automated-design-optimization", 
            "text": "This section of the  meep  documentation\ncovers  meep . adjoint ,  a submodule of the  meep  python module\nthat implements an  adjoint-based sensitivity solver \nto facilitate automated design optimization via derivative-based numerical optimizers.     table of contents  The  meep.adjoint  documentation is divided into a number of subsections:    This  Overview  page reviews some basic facts about adjoints and optimizers,\n  outlines the steps needed to prepare a  meep \n  geometry for optimization, and sketches the mechanics of\n  the  meep.adjoint  design process.\n  (This page is designed to be a gentle introduction for the\n  adjoint neophyte; experts may want only to skim it before\n  skipping to the next section.)    The  Reference Manual  fills in the details of \n  the topics outlined on this page, spelling out exactly how to\n  write the python script that will drive your optimization\n  session.    The  Example Gallery  presents a number\n  of worked examples that illustrate how  meep.adjoint  tackles\n  practical problems in various settings.    The  Implementation Notes  page\n  offers a glimpse of what's behind the hood---the physical \n   and mathematical basis of the adjoint method and how they\n  are implemented by  meep.adjoint.  An understanding of this \n  content is not strictly necessary to use the solver, but may\n  help you get more out of the process.    Although logically independent of the adjoint solver,\n  the  Visualization  package bundled\n with the  meep.adjoint  module offers several general-purpose\n  utilities for convenient visualization of various aspects\n of  meep  calculations, which are\n useful in  any  meep calculation whether adjoint-related\n or not.", 
            "title": "meep.adjoint: Adjoint sensitivity analysis for automated design optimization"
        }, 
        {
            "location": "/AdjointSolver/Overview/#overview-adjoint-based-optimization", 
            "text": "A common task in electromagnetic engineering is to custom-tune the design\nof some component of a system---a waveguide taper, a power splitter,\nan input coupler, an antenna, etc.---to optimize the performance of the system\nas defined by some problem-specific metric. For our purposes,\na \"design\" will consist of a specification of the spatially-varying\nscalar permittivity  \\epsilon(\\mathbf x) \\epsilon(\\mathbf x)  in some subregion\nof a  meep  geometry, and the performance metric\nwill be a physical quantity computed from frequency-domain\nfields---a  power flux ,\nan  energy density ,\nan eigenmode expansion coefficient ,\nor perhaps some mathematical function of one or more of these\nquantities. We will shortly present a smorgasbord of examples; for now,\nperhaps a good one to have in mind is the hole cloak   discussed below, in which a\nchunk of material has been removed from an otherwise perfect waveguide\nsection, ruining the otherwise perfectly unidirectional (no scattering or reflection)\nflow of power from a source at one end of the guide to a sink at the other;\nour task is to tweak the permittivity in an annular region\nsurrounding the defect (the  cloak ) so as to restore \nas much as possible the reflectionless transfer of power \nacross the waveguide---thus hiding or \"cloaking\"\nthe presence of defect from external detection.  Now, given a candidate design \\epsilon\\sup{trial}(\\mathbf{x}) \\epsilon\\sup{trial}(\\mathbf{x}) , it's easy enough to see\nhow we can use  meep  to evaluate\nits performance---just create a meep  geometry with  \\epsilon\\sup{trial} \\epsilon\\sup{trial}  as a spatially-varying permittivity function ,\nin the design region,\nadd  DFT cells \nto tabulate the frequency-domain Poynting flux entering and departing\nthe cloak region, timestep  until\nthe DFTs converge, then use post-processing routines like get_fluxes ( ) \nor perhaps get_eigenmode_coefficients () \nto get the quantities needed to evaluate the performance of the device.\nThus, for the cost of one full  meep  timestepping\nrun we obtain the value of our objective function at one point\nin the parameter space of possible inputs.   But  now  what do we do?! The difficulty is that the computation\nizinust described furnishes only the  value  of the objective function\nfor a given input, not its  derivatives  with respect to the\ndesign variables---and thus yields zero insight into how we should\ntweak the design to improve performance.\nIn simple cases we might hope to proceed on the basis of physical\nintuition, while\nfor small problems with just a few parameters we might try our luck with a derivative-free optimization algorithm ;\nhowever, both of these approaches will run out of steam long before\nwe scale up to \nthe full complexity of a practical problem with thousands\nof degrees of freedom.\nAlternatively, we could get approximate derivative information by brute-force\nfinite-differencing---slightly tweaking one design variable, repeating \nthe full timestepping run, and asking how the results changed---but \nproceeding this way to compute derivatives with respect to all  D D  \ndesign variables would require fully  D D  separate timestepping runs;\nfor the problem sizes we have in mind, this would make calculating the \nobjective-function gradient several thousand times  more costly than calculating its value.\nSo we face a dilemma: How can we obtain the derivative information\nnecessary for effective optimization in a reasonable amount of time?\nThis is where adjoints come to the rescue.  The  adjoint method  of sensitivity analysis is a technique in which\nwe exploit certain facts about the physics of a problem and the\nconsequent mathematical structure---specifically, in this case, the\nlinearity and reciprocity of Maxwell's equations---to rearrange the\ncalculation of derivatives in a way that yields an  enormous  speedup\nover the brute-force finite-difference approach. More specifically,\nafter we have computed the objective-function value by doing\nthe full  meep  timestepping run mentioned\nabove---the \"forward\" run in adjoint-method parlance---we can magically\ncompute its derivatives with respect to  all  design variables by doing\njust  one  additional timestepping run with a funny-looking choice\nof sources and outputs (the \"adjoint\" run).\nThus, whereas gradient computation via finite-differencing is at least  D D \ntimes more expensive than computing the objective function value,\nwith adjoints we get both value and gradient for roughly just  twice  the\ncost of the value alone. Such a bargain! At this modest cost, derivative-based \noptimization becomes entirely feasible.     More general materials \n    Although for simplicity we focus here on case of isotropic,\n    non-magnetic materials, the adjoint solver is also capable\n    of optimizing geometries involving permeable ( \\mu\\ne 1 \\mu\\ne 1 ) and\n    anisotropic (tensor-valued  \\boldsymbol{\\epsilon},\\boldsymbol{\\mu} \\boldsymbol{\\epsilon},\\boldsymbol{\\mu} ) media.", 
            "title": "Overview: Adjoint-based optimization"
        }, 
        {
            "location": "/AdjointSolver/Overview/#examples-of-optimization-problems", 
            "text": "Throughout the  meep.adjoint  documentation we will refer to a running collection of \nsimple optimization problems to illustrate the mechanics of optimization,\namong which are the following; click the geometry images to view \nin higher resolution.", 
            "title": "Examples of optimization problems"
        }, 
        {
            "location": "/AdjointSolver/Overview/#the-holey-waveguide", 
            "text": "By way of warm-up, a useful toy version of an optimization problem\nis an otherwise pristine length of dielectric slab waveguide in\nwhich a careless technician has torn a circular  hole  of variable\npermittivity  \\epsilon\\sup{hole} \\epsilon\\sup{hole} .           Incident power from an eigenmode source  (cyan line in figure)\ntravels leftward through the waveguide, but is partially \nreflected by the hole, resulting in less than 100% power\nthe waveguide output (as may be \ncharacterized in  meep \nby observing power flux and/or\neigenmode expansion coefficients at the two \nflux monitors, labeled  east  and  west ).\nOur objective is to tweak the value of \\epsilon\\sup{hole} \\epsilon\\sup{hole}  to maximize transmission\nas assessed by one of these metrics.\nThe simplicity of this model makes it a useful\ninitial warm-up and sanity check for making sure we know\nwhat we are doing in design optimization; for example,  in this worked example \nwe use it to confirm the numerical accuracy of\nadjoint-based gradients computed by  mp.adjoint", 
            "title": "The Holey Waveguide"
        }, 
        {
            "location": "/AdjointSolver/Overview/#the-hole-cloak", 
            "text": "We obtain a more challenging variant of the holey-waveguide problem\nbe supposing that the material in the hole region is  not  a\ntunable design parameter---it is fixed at vacuum, say, or \nperfect metal---but that we  are  allowed to vary the permittivity\nin an annular region surrounding the hole in such a way\nas to mimic the effect of filling in the hole, i.e. of hiding\nor \"cloaking\" the hole  as much as  possible from external \n detection.      For the hole-cloak optimization, the objective function\nwill most likely the same as that considered above---namely,\nto maximize the Poynting flux through the flux monitor\nlabeled  east  (a quantity we label  S\\subs{east} S\\subs{east} )\n or perhaps to maximize the overlap coefficient\nbetween the actual fields passing through monitor east  and the fields of (say)\nthe  n n th forward- or backward-traveling eigenmode\nof the waveguide (which we label  \\{P,M\\}_{n,\\text{east}} \\{P,M\\}_{n,\\text{east}} \nwith  P,M P,M  standing for \"plus and minus.\")\nOn the other hand, the design space here is more \ncomplicated than for the simple hole, consisting\nof all possible scalar functions  \\epsilon(r,\\theta) \\epsilon(r,\\theta)  \ndefined on the annular cloak region.", 
            "title": "The Hole Cloak"
        }, 
        {
            "location": "/AdjointSolver/Overview/#the-cross-router", 
            "text": "A different flavor of waveguide-optimization problem arises when we\nconsider the  routing  of signals from given inputs to \ngiven destinations. One example is the  cross-router , involving\nan intersection between  x- x- directed and  y- y- directed waveguides,\nwith center region of variable permittivity that we may\ntweak to control the routing of power through it.      Whereas in the previous examples there was more or less\nonly one reasonable design objective one might realistically\nwant to optimize,\nfor a problem like this there are many possibilities.\nFor example, given fixed input power supplied by an eigenmode\nsource on the \"western\" branch (cyan line),\nwe might be less interested in the absolute output\npower at any port and more concerned with \nachieving maximal  equality  of output \npower among the north, south, and east outputs,\nwhereupon we might minimize an objective function of\nthe form\n$$f\\sub{obj}  =\n   \\Big( S\\sub{north} - S\\sub{south}\\Big)^2\n  +\\Big( S\\sub{north} - S\\sub{east}\\Big)^2\n + \\Big( S\\sub{east} - S\\sub{south}\\Big)^2\n$$\n(or a similar functional form involving eigenmode \ncoefficients).\nAlternatively, perhaps we don't care what happens in\nthe southern branch, but we really want the fields \ntraveling past the  north  monitor \nto have twice as much\noverlap with the forward-traveling 3 rd  eigenmode of that\nwaveguide \nas the  east  fields have with their backward-traveling\n2 nd  eigenmode:    f\\sub{obj} \\equiv \\Big( P\\sub{3,north} - 2M\\sub{2,east}\\Big)^2   f\\sub{obj} \\equiv \\Big( P\\sub{3,north} - 2M\\sub{2,east}\\Big)^2   The point is that the definition of an optimization problem\ninvolves not only a set of physical quantities  (power fluxes, eigenmode coefficients,\netc.) that we compute from  meep  calculations,\nbut also a rule (the objective function  f f ) for crunching those \nnumbers in some specific way to define a single scalar figure of merit.   In   mp.adjoint  we use the collective term  objective quantities \nfor the power fluxes, eigenmode coefficients, and other physical quantities\nneeded to compute the objective function.\nSimilarly, the special geometric subregions of  meep  geometries with\nwhich objective quantities are associated---the\ncross-sectional flux planes of  DFTFlux  cells or \nfield-energy boxes of  DFTField  cells----are known as  objective regions.  The [Example Gallery][ExampleGallery.md] includes a worked example\nof a full successful iterative optimization in which mp.adjoint  begins with the design shown above and thoroughly rejiggers\nit over the course of 50 iterations to yield a device\nthat efficiently routs power around a 90  bend\nfrom the eigenmode source (cyan line above)\nto the 'north' output port.", 
            "title": "The cross-router"
        }, 
        {
            "location": "/AdjointSolver/Overview/#the-asymmetric-splitter", 
            "text": "A  splitter  seeks to divide incoming power from one source\nin some specific way among two or more destinations.,\nWe will consider an asymmetric splitter in which power\narriving from a single incoming waveguide is to be routed\ninto two outgoing waveguides by varying the design of the \ncentral coupler region:", 
            "title": "The asymmetric splitter"
        }, 
        {
            "location": "/AdjointSolver/Overview/#common-elements-of-optimization-geometries-objective-regions-objective-functions-design-regions-basis-sets", 
            "text": "The examples above, distinct though they all are, illustrate\nthe common defining features that are present in every meep  optimization problem:   Objective regions:  One or more  regions over which to tabulate frequency-domain fields (DFT cells) \n  for use in computing power fluxes, mode-expansion coefficients, and other frequency-domain\n   quantities used in characterizing device performance.  Because these regions are used to evaluate\n   objective functions, we refer to them as  objective regions.      Objective regions may or may not have zero thickness \n    In the examples above, it happens that all objective regions are one-dimensional\n    (zero-thickness) flux monitors, indicated by magenta lines; in a 3D geometry they\n    would be two-dimensional flux planes, still of zero thickness in the normal \n    direction.  However, objective regions may also be of nonzero thickness, as for\n    instance if the objective function involves the  field energy in a box-shaped\n    subregion of a geometry.     Objective quantities and the objective function:  \n      A specification of which quantities (power fluxes, mode coefficients,\n      energies, etc.) are to be computed for each objective region, and how\n      those quantities are to be crunched mathematically to yield a single number \n      measuring device performance. We refer to the individual quantities as \n       objective quantities , while the overall function that inputs one more more\n      objective quantities and outputs a single numerical score is the \n       objective function.    Design region:  A specification of the region over which the material design is to be\n    optimized, i.e. the region in which the permittivity is given by the\n    design quantity  \\epsilon\\sup{des}(\\mathbf x) \\epsilon\\sup{des}(\\mathbf x) .\n    We refer to this as the  design region   \\mathcal{V}\\sup{des} \\mathcal{V}\\sup{des} .    Basis:  Because the design variable  \\epsilon\\sup{des}(\\mathbf x) \\epsilon\\sup{des}(\\mathbf x) \n    is a continuous function defined throughout a finite volume of space,\n    technically it involves infinitely many degrees of freedom.\n    To yield a finite-dimensional optimization problem, it is convenient\n    to approximate  \\epsilon\\sup{des} \\epsilon\\sup{des}  as a finite expansion in some\n    convenient set of basis functions, i.e.\n    $$ \\epsilon(\\mathbf x) \\equiv \\sum_{d=1}^N \\beta_d \\mathcal{b}_d(\\mathbf x),\n       \\qquad \\mathbf x\\in \\mathcal{V}\\sup{des},\n    $$\n    where  \\{\\mathcal{b}_n(\\mathbf x)\\} \\{\\mathcal{b}_n(\\mathbf x)\\}  is a set of  D D  scalar-valued\n    basis functions defined for  \\mathbf x\\in\\mathcal{V}\\sup{des} \\mathbf x\\in\\mathcal{V}\\sup{des} .\n    The task of the optimizer then becomes to determine\n    numerical values for the  N N -vector of coefficients \n     \\boldsymbol{\\beta}=\\{\\beta_n\\},n=1,\\cdots,N. \\boldsymbol{\\beta}=\\{\\beta_n\\},n=1,\\cdots,N.  For adjoint optimization in  meep , the\nbasis set is chosen by the user, either from among a predefined collection of\ncommon basis sets, or as an arbitrary user-defined basis set specified by\nsubclassing an abstract base class in  mp.adjoint.", 
            "title": "Common elements of optimization geometries: Objective regions, objective functions, design regions, basis sets"
        }, 
        {
            "location": "/AdjointSolver/Overview/#mechanics-of-meep-design-optimization", 
            "text": "With all that by way of background, here's a quick rundown of the \nprocess you'll follow to optimize a geometry in  meep.adjoint.   You write a python script that implements a subclass of\n    OptimizationProblem  (an abstract base class in  meep.adjoint )\n   to describe your specific problem. In particular, your \n   class must override the following two pure virtual methods\n   in  OptimizationProblem:   init_problem : One-time initialization Inputs an  args  structure describing command-line options\nand returns a 5-tuple     fstr ,   objective_regions ,   extra_regions ,   design_region ,   basis  \ndefining your objective function, the objective regions on which \nits inputs (the objective variables) are defined, the design region,\nand an expansion basis.   create_sim : Instantiation of design-dependent geometries Inputs a vector of expansion coefficients  beta_vector  and \nreturns a  meep.simulation  describing a geometry with the \ncorresponding spatially-varying permittivity.    You run computations on your geometry either by executing your\n   script from the shell with command-line options:     % python HoleyWaveguide.py --beta  0   2 .3 --eval_gradient  or equivalently from a python script or console by \ncalling its  run()  method:     from   HoleyWaveguide   import   HoleyWaveguide \n\n   HW = HoleyWaveguide ( cmdline = --beta 0 2.3 --eval_gradient ) \n   HW . run ()   The actual calculations that may be run in this way\nrange from a single non-iterative computation of the objective\nfunction and (optionally) its gradient at a given set of design-variable\nvalues, to  full-blown iterative design optimization  Here, in their entirety, are the python scripts implementing the 4 examples\ndescribed above. (These may also be found in the  python/examples/adjoint_optimization \nsubdirectory of your  meep  installation.)  HoleyWaveguide.py import   sys  import   argparse  import   numpy   as   np  import   meep   as   mp  from   meep.adjoint   import   ( OptimizationProblem ,   DFTCell ,   adjoint_options , \n                           xHat ,   yHat ,   zHat ,   origin ,   FluxLine , \n                           ParameterizedDielectric ,   FourierLegendreBasis )  ##################################################  ##################################################  ##################################################  class   HoleyWaveguide ( OptimizationProblem ): \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   add_args ( self ,   parser ): \n\n         # add new problem-specific arguments \n         parser . add_argument ( --dair ,          type = float ,   default =- 1.0 ,   help = ) \n         parser . add_argument ( --w_wvg ,         type = float ,   default = 3.0 ,    help = ) \n         parser . add_argument ( --eps_wvg ,       type = float ,   default = 6.0 ,    help = ) \n         parser . add_argument ( --r_disc ,        type = float ,   default = 0.5 ,    help = ) \n         parser . add_argument ( --nr_max ,        type = int ,     default = 0 ,      help = ) \n         parser . add_argument ( --kphi_max ,      type = int ,     default = 0 ,      help = ) \n\n         # set problem-specific defaults for existing (general) arguments \n         parser . set_defaults ( fcen = 0.5 ) \n         parser . set_defaults ( df = 0.2 ) \n         parser . set_defaults ( dpml = 1.0 ) \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   init_problem ( self ,   args ): \n\n         #---------------------------------------- \n         # size of computational cell \n         #---------------------------------------- \n         lcen         =   1.0 / args . fcen \n         dpml         =   0.5 * lcen   if   args . dpml ==- 1.0   else   args . dpml \n         dair         =   0.5 * args . w_wvg   if   args . dair ==- 1.0   else   args . dair \n         L            =   3.0 * lcen \n         Lmin         =   6.0 * dpml   +   2.0 * args . r_disc \n         L            =   max ( L , Lmin ) \n         sx           =   dpml + L + dpml \n         sy           =   dpml + dair + args . w_wvg + dair + dpml \n         cell_size    =   mp . Vector3 ( sx , sy ) \n\n         #---------------------------------------- \n         #- design region \n         #---------------------------------------- \n         design_center   =   origin \n         design_size     =   mp . Vector3 ( 2.0 * args . r_disc ,   2.0 * args . r_disc ) \n         design_region   =   mp . Volume ( center = design_center ,   size = design_size ) \n\n         #---------------------------------------- \n         #- objective regions \n         #---------------------------------------- \n         x0_east         =    args . r_disc   +   dpml \n         x0_west         =   - args . r_disc   -   dpml \n         y0              =   0.0 \n         flux_length     =   2.0 * args . w_wvg \n         east            =   FluxLine ( x0_east , y0 , flux_length , mp . X , east ) \n         west            =   FluxLine ( x0_west , y0 , flux_length , mp . X , west ) \n\n         objective_regions    =   [ east ,   west ] \n\n         #---------------------------------------- \n         #- optional extra regions for visualization \n         #---------------------------------------- \n         extra_regions        =   [ mp . Volume ( center = origin ,   size = cell_size )]   if   args . full_dfts   else   [] \n\n         #---------------------------------------- \n         # basis set \n         #---------------------------------------- \n         basis   =   FourierLegendreBasis ( radius = args . r_disc ,   nr_max = args . nr_max ,   kphi_max = args . kphi_max ) \n\n         #---------------------------------------- \n         #- source location \n         #---------------------------------------- \n         source_center      =   ( x0_west   -   dpml ) * xHat \n         source_size        =   flux_length * yHat \n\n         #---------------------------------------- \n         #- objective function \n         #---------------------------------------- \n         fstr = Abs(P1_east)**2+0.0*(P2_east+P1_west+P2_west+M1_east+M2_east+M1_west+M2_west+S_east+S_west) \n\n         #---------------------------------------- \n         #- internal storage for variables needed later \n         #---------------------------------------- \n         self . args              =   args \n         self . dpml              =   dpml \n         self . cell_size         =   cell_size \n         self . basis             =   basis \n         self . design_center     =   design_center \n         self . source_center     =   source_center \n         self . source_size       =   source_size \n\n         return   fstr ,   objective_regions ,   extra_regions ,   design_region ,   basis \n\n     ############################################################## \n     ############################################################## \n     ############################################################## \n     def   create_sim ( self ,   beta_vector ,   vacuum = False ): \n\n         args = self . args \n         sx = self . cell_size . x \n\n         wvg = mp . Block ( center = origin ,   material = mp . Medium ( epsilon = args . eps_wvg ), \n                      size = mp . Vector3 ( self . cell_size . x , args . w_wvg )) \n         disc = mp . Cylinder ( center = self . design_center ,   radius = args . r_disc , \n                          epsilon_func = ParameterizedDielectric ( self . design_center , \n                                                               self . basis , \n                                                               beta_vector )) \n\n         geometry = [ wvg ]   if   vacuum   else   [ wvg ,   disc ] \n\n         envelope   =   mp . GaussianSource ( args . fcen , fwidth = args . df ) \n         amp = 1.0 \n         if   callable ( getattr ( envelope ,   fourier_transform ,   None )): \n             amp   /=   envelope . fourier_transform ( args . fcen ) \n         sources = [ mp . EigenModeSource ( src = envelope , \n                                     center = self . source_center , \n                                     size = self . source_size , \n                                     eig_band = self . args . source_mode , \n                                     amplitude = amp \n                                    ) \n                 ] \n\n         sim = mp . Simulation ( resolution = args . res ,   cell_size = self . cell_size , \n                           boundary_layers = [ mp . PML ( args . dpml )],   geometry = geometry , \n                           sources = sources ) \n\n         if   args . complex_fields : \n             sim . force_complex_fields = True \n\n         return   sim  ######################################################################  # if executed as a script, we look at our own filename to figure out  # the name of the class above, create an instance of this class called  # opt_prob, and call its run() method.  ######################################################################  if   __name__   ==   __main__ : \n     opt_prob = globals ()[ __file__ . split ( / )[ - 1 ] . split ( . )[ 0 ]]() \n     opt_prob . run ()      HoleCloak.py  import   sys  import   argparse  import   numpy   as   np  import   meep   as   mp  from   meep.adjoint   import   ( OptimizationProblem ,   DFTCell ,   adjoint_options , \n                           xHat ,   yHat ,   zHat ,   origin ,   FluxLine , \n                           ParameterizedDielectric ,   FourierLegendreBasis )  ##################################################  ##################################################  ##################################################  class   HoleCloak ( OptimizationProblem ): \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   add_args ( self ,   parser ): \n\n         # add new problem-specific arguments \n         parser . add_argument ( --dair ,          type = float ,   default =- 1.0 ,   help = ) \n         parser . add_argument ( --w_wvg ,         type = float ,   default = 4.0 ,    help = ) \n         parser . add_argument ( --eps_wvg ,       type = float ,   default = 6.0 ,    help = ) \n         parser . add_argument ( --r_disc ,        type = float ,   default = 0.5 ,    help = ) \n         parser . add_argument ( --r_cloak ,       type = float ,   default = 1.5 ,    help = ) \n         parser . add_argument ( --nr_max ,        type = int ,     default = 3 ,      help = ) \n         parser . add_argument ( --kphi_max ,      type = int ,     default = 2 ,      help = ) \n         parser . add_argument ( --eps_disc ,      type = float ,   default = 1.0 ,    help = permittivity in hole region (0.0 for PEC) ) \n\n         # set problem-specific defaults for existing (general) arguments \n         parser . set_defaults ( fcen = 0.5 ) \n         parser . set_defaults ( df = 0.2 ) \n         parser . set_defaults ( dpml = 1.0 ) \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   init_problem ( self ,   args ): \n\n         #---------------------------------------- \n         # size of computational cell \n         #---------------------------------------- \n         lcen         =   1.0 / args . fcen \n         dpml         =   0.5 * lcen   if   args . dpml ==- 1.0   else   args . dpml \n         dair         =   0.5 * args . w_wvg   if   args . dair ==- 1.0   else   args . dair \n         L            =   3.0 * lcen \n         Lmin         =   6.0 * dpml   +   2.0 * args . r_cloak \n         L            =   max ( L , Lmin ) \n         sx           =   dpml + L + dpml \n         sy           =   dpml + dair + args . w_wvg + dair + dpml \n         cell_size    =   mp . Vector3 ( sx ,   sy ,   0.0 ) \n\n         #---------------------------------------- \n         #- design region \n         #---------------------------------------- \n         design_center   =   origin \n         design_size     =   mp . Vector3 ( 2.0 * args . r_cloak ,   2.0 * args . r_cloak ) \n         design_region   =   mp . Volume ( center = design_center ,   size = design_size ) \n\n         #---------------------------------------- \n         #- objective regions \n         #---------------------------------------- \n         fluxW_center    =    ( + args . r_cloak +   dpml ) * xHat \n         fluxE_center    =    ( - args . r_cloak -   dpml ) * xHat \n         flux_size       =    2.0 * args . w_wvg * yHat \n\n         #fluxW_region  = mp.FluxRegion(center=fluxW_center, size=flux_size, direction=mp.X) \n         #fluxE_region  = mp.FluxRegion(center=fluxE_center, size=flux_size, direction=mp.X) \n         x0_east         =    args . r_cloak   +   dpml \n         x0_west         =   - args . r_cloak   -   dpml \n         y0              =   0.0 \n         flux_length     =   2.0 * args . w_wvg \n         east            =   FluxLine ( x0_east , y0 , flux_length , mp . X , east ) \n         west            =   FluxLine ( x0_west , y0 , flux_length , mp . X , west ) \n\n         objective_regions    =   [ east ,   west ] \n\n         #---------------------------------------- \n         #- optional extra regions for visualization \n         #---------------------------------------- \n         extra_regions        =   [ mp . Volume ( center = origin ,   size = cell_size )]   if   args . full_dfts   else   [] \n\n         #---------------------------------------- \n         # basis set \n         #---------------------------------------- \n         basis   =   FourierLegendreBasis ( outer_radius = args . r_cloak ,   inner_radius = args . r_disc , \n                                      nr_max = args . nr_max ,   kphi_max = args . kphi_max ) \n\n         #---------------------------------------- \n         #- source location \n         #---------------------------------------- \n         source_center      =   ( x0_west - dpml ) * xHat \n         source_size        =   flux_length * yHat \n\n         #---------------------------------------- \n         #- objective function \n         #---------------------------------------- \n         fstr = Abs(P1_east)**2+0.0*(P1_west + M1_east + M1_west + S_west + S_east) \n\n         #---------------------------------------- \n         #- internal storage for variables needed later \n         #---------------------------------------- \n         self . args              =   args \n         self . dpml              =   dpml \n         self . cell_size         =   cell_size \n         self . basis             =   basis \n         self . design_center     =   design_center \n         self . source_center     =   source_center \n         self . source_size       =   source_size \n\n         return   fstr ,   objective_regions ,   extra_regions ,   design_region ,   basis \n\n     ############################################################## \n     ############################################################## \n     ############################################################## \n     def   create_sim ( self ,   beta_vector ,   vacuum = False ): \n\n         args = self . args \n         sx = self . cell_size . x \n\n         wvg = mp . Block ( center = origin ,   material = mp . Medium ( epsilon = args . eps_wvg ), \n                      size = mp . Vector3 ( self . cell_size . x , args . w_wvg )) \n         cloak = mp . Cylinder ( center = self . design_center ,   radius = args . r_cloak , \n                           epsilon_func = ParameterizedDielectric ( self . design_center , \n                                                                self . basis , \n                                                                beta_vector )) \n         disc = mp . Cylinder ( center = self . design_center ,   radius = args . r_disc , \n                          material = ( mp . metal   if   args . eps_disc == 0   else \n                                    mp . Medium ( epsilon = args . eps_disc ))) \n\n         geometry = [ wvg ]   if   vacuum   else   [ wvg ,   cloak ,   disc ] \n\n         envelope   =   mp . GaussianSource ( args . fcen , fwidth = args . df ) \n         amp = 1.0 \n         if   callable ( getattr ( envelope ,   fourier_transform ,   None )): \n             amp   /=   envelope . fourier_transform ( args . fcen ) \n         sources = [ mp . EigenModeSource ( src = envelope , \n                                     center = self . source_center , \n                                     size = self . source_size , \n                                     eig_band = self . args . source_mode , \n                                     amplitude = amp \n                                    ) \n                 ] \n\n         sim = mp . Simulation ( resolution = args . res ,   cell_size = self . cell_size , \n                           boundary_layers = [ mp . PML ( args . dpml )],   geometry = geometry , \n                           sources = sources ) \n\n         if   args . complex_fields : \n             sim . force_complex_fields = True \n\n         return   sim  ######################################################################  # if executed as a script, we look at our own filename to figure out  # the name of the class above, create an instance of this class called  # opt_prob, and call its run() method.  ######################################################################  if   __name__   ==   __main__ : \n     opt_prob = globals ()[ __file__ . split ( / )[ - 1 ] . split ( . )[ 0 ]]() \n     opt_prob . run ()     CrossRouter.py  import   numpy   as   np  import   meep   as   mp  from   meep.adjoint   import   ( OptimizationProblem ,   FluxLine , \n                           xHat ,   yHat ,   zHat ,   origin , \n                           ParameterizedDielectric ,   FiniteElementBasis )  ##################################################  ##################################################  ##################################################  class   CrossRouter ( OptimizationProblem ): \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   add_args ( self ,   parser ): \n\n         # add new problem-specific arguments \n         parser . add_argument ( --wh ,         type = float ,   default = 1.5 ,    help = width of horizontal waveguide ) \n         parser . add_argument ( --wv ,         type = float ,   default = 1.5 ,    help = width of vertical waveguide ) \n         parser . add_argument ( --l_stub ,     type = float ,   default = 3.0 ,    help = waveguide input/output stub length ) \n         parser . add_argument ( --eps ,        type = float ,   default = 6.0 ,    help = waveguide permittivity ) \n         parser . add_argument ( --r_design ,   type = float ,   default = 0.0 ,    help = design region radius ) \n         parser . add_argument ( --l_design ,   type = float ,   default = 4.0 ,    help = design region side length ) \n         parser . add_argument ( --nfe ,        type = int ,     default = 2 ,      help = number of finite elements per unit length ) \n         parser . add_argument ( --n_weight ,   type = float ,   default = 1.00 ,   help = ) \n         parser . add_argument ( --s_weight ,   type = float ,   default = 0.00 ,   help = ) \n         parser . add_argument ( --e_weight ,   type = float ,   default = 0.00 ,   help = ) \n\n         # set problem-specific defaults for existing (general) arguments \n         parser . set_defaults ( fcen = 0.5 ) \n         parser . set_defaults ( df = 0.2 ) \n         parser . set_defaults ( dpml = 1.0 ) \n         parser . set_defaults ( epsilon_design = 6.0 ) \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   init_problem ( self ,   args ): \n\n         #---------------------------------------- \n         # size of computational cell \n         #---------------------------------------- \n         lcen            =   1.0 / args . fcen \n         dpml            =   0.5 * lcen   if   args . dpml   ==   - 1.0   else   args . dpml \n         design_length   =   2.0 * args . r_design   if   args . r_design     0.0   else   args . l_design \n         sx   =   sy         =   dpml   +   args . l_stub   +   design_length   +   args . l_stub   +   dpml \n         cell_size       =   mp . Vector3 ( sx ,   sy ,   0.0 ) \n\n         #---------------------------------------- \n         #- design region bounding box \n         #---------------------------------------- \n         design_center   =   origin \n         design_size     =   mp . Vector3 ( design_length ,   design_length ) \n         design_region   =   mp . Volume ( center = design_center ,   size = design_size ) \n\n         #---------------------------------------- \n         #- objective and source regions \n         #---------------------------------------- \n         gap              =    args . l_stub / 6.0                      # gap between source region and flux monitor \n         d_flux           =    0.5 * ( design_length   +   args . l_stub )    # distance from origin to NSEW flux monitors \n         d_source         =    d_flux   +   gap                         # distance from origin to source \n         d_flx2           =    d_flux   +   2.0 * gap \n         l_flux_NS        =    2.0 * args . wv \n         l_flux_EW        =    2.0 * args . wh \n         north            =    FluxLine ( 0.0 ,   + d_flux ,   l_flux_NS ,   mp . Y ,   north ) \n         south            =    FluxLine ( 0.0 ,   - d_flux ,   l_flux_NS ,   mp . Y ,   south ) \n         east             =    FluxLine ( + d_flux ,   0.0 ,   l_flux_EW ,   mp . X ,   east ) \n         west1            =    FluxLine ( - d_flux ,   0.0 ,   l_flux_EW ,   mp . X ,   west1 ) \n         west2            =    FluxLine ( - d_flx2 ,   0.0 ,   l_flux_EW ,   mp . X ,   west2 ) \n\n         objective_regions    =   [ north ,   south ,   east ,   west1 ,   west2 ] \n\n         source_center    =    mp . Vector3 ( - d_source ,   0.0 ) \n         source_size      =    mp . Vector3 ( 0.0 , l_flux_EW ) \n\n         #---------------------------------------- \n         #- optional extra regions for visualization \n         #---------------------------------------- \n         extra_regions    =   [ mp . Volume ( center = origin ,   size = cell_size )]   if   args . full_dfts   else   [] \n\n         #---------------------------------------- \n         # basis set \n         #---------------------------------------- \n         basis   =   FiniteElementBasis ( lx = args . l_design ,   ly = args . l_design ,   density = args . nfe ) \n\n         #---------------------------------------- \n         #- objective function \n         #---------------------------------------- \n         fstr = (         {:s} *Abs(P1_north)**2 . format ( 0.0   if   args . n_weight == 0.0   else   {} . format ( args . n_weight )) \n                +    +  {:s} *Abs(M1_south)**2 . format ( 0.0   if   args . s_weight == 0.0   else   {} . format ( args . s_weight )) \n                +    +  {:s} *Abs(P1_east)**2 . format ( 0.0    if   args . e_weight == 0.0   else   {} . format ( args . e_weight )) \n                +    + 0.0*(P1_north + M1_south + P1_east + P1_west1 + P1_west2) \n                +    + 0.0*(M1_north + M1_south + M1_east + M1_west1 + M1_west2) \n                +    + 0.0*(S_north + S_south + S_east + S_west1 + S_west2) \n              ) \n\n         #---------------------------------------- \n         #- internal storage for variables needed later \n         #---------------------------------------- \n         self . args              =   args \n         self . dpml              =   dpml \n         self . cell_size         =   cell_size \n         self . basis             =   basis \n         self . design_center     =   design_center \n         self . design_size       =   design_size \n         self . source_center     =   source_center \n         self . source_size       =   source_size \n\n         if   args . eps_design   is   None : \n             args . eps_design   =   args . eps \n\n         return   fstr ,   objective_regions ,   extra_regions ,   design_region ,   basis \n\n     ############################################################## \n     ############################################################## \n     ############################################################## \n     def   create_sim ( self ,   beta_vector ,   vacuum = False ): \n\n         args = self . args \n\n         hwvg = mp . Block ( center = origin ,   material = mp . Medium ( epsilon = args . eps ), \n                       size = mp . Vector3 ( self . cell_size . x , args . wh )) \n         vwvg = mp . Block ( center = origin ,   material = mp . Medium ( epsilon = args . eps ), \n                       size = mp . Vector3 ( args . wv , self . cell_size . y )) \n\n         if   args . r_design 0.0 : \n             router = mp . Cylinder ( center = self . design_center ,   radius = args . r_design , \n                                epsilon_func = ParameterizedDielectric ( self . design_center , \n                                                                     self . basis , \n                                                                     beta_vector )) \n         else : \n             router = mp . Block ( center = self . design_center ,   size = self . design_size , \n                             epsilon_func = ParameterizedDielectric ( self . design_center , \n                                                                  self . basis , \n                                                                  beta_vector )) \n         geometry = [ hwvg ,   vwvg ,   router ] \n\n         envelope   =   mp . GaussianSource ( args . fcen , fwidth = args . df ) \n         amp = 1.0 \n         if   callable ( getattr ( envelope ,   fourier_transform ,   None )): \n             amp   /=   envelope . fourier_transform ( args . fcen ) \n         sources = [ mp . EigenModeSource ( src = envelope , \n                                     center = self . source_center , \n                                     size = self . source_size , \n                                     eig_band = args . source_mode , \n                                     amplitude = amp \n                                    ) \n                 ] \n\n         sim = mp . Simulation ( resolution = args . res ,   cell_size = self . cell_size , \n                           boundary_layers = [ mp . PML ( self . dpml )],   geometry = geometry , \n                           sources = sources ) \n\n         if   args . complex_fields : \n             sim . force_complex_fields = True \n\n         return   sim  ######################################################################  # if executed as a script, we look at our own filename to figure out  # the name of the class above, create an instance of this class called  # op, and call its run() method.  ######################################################################  if   __name__   ==   __main__ : \n     op = globals ()[ __file__ . split ( / )[ - 1 ] . split ( . )[ 0 ]]() \n     op . run ()     AsmmetricSplitter.py   import   numpy   as   np  import   meep   as   mp  from   meep.adjoint   import   ( OptimizationProblem ,   FluxLine , \n                           xHat ,   yHat ,   zHat ,   origin , \n                           ParameterizedDielectric ,   FiniteElementBasis )  ##################################################  ##################################################  ##################################################  class   CrossRouter ( OptimizationProblem ): \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   add_args ( self ,   parser ): \n\n         # add new problem-specific arguments \n         parser . add_argument ( --wh ,         type = float ,   default = 1.5 ,    help = width of horizontal waveguide ) \n         parser . add_argument ( --wv ,         type = float ,   default = 1.5 ,    help = width of vertical waveguide ) \n         parser . add_argument ( --l_stub ,     type = float ,   default = 3.0 ,    help = waveguide input/output stub length ) \n         parser . add_argument ( --eps ,        type = float ,   default = 6.0 ,    help = waveguide permittivity ) \n         parser . add_argument ( --r_design ,   type = float ,   default = 0.0 ,    help = design region radius ) \n         parser . add_argument ( --l_design ,   type = float ,   default = 4.0 ,    help = design region side length ) \n         parser . add_argument ( --nfe ,        type = int ,     default = 2 ,      help = number of finite elements per unit length ) \n         parser . add_argument ( --n_weight ,   type = float ,   default = 1.00 ,   help = ) \n         parser . add_argument ( --s_weight ,   type = float ,   default = 0.00 ,   help = ) \n         parser . add_argument ( --e_weight ,   type = float ,   default = 0.00 ,   help = ) \n\n         # set problem-specific defaults for existing (general) arguments \n         parser . set_defaults ( fcen = 0.5 ) \n         parser . set_defaults ( df = 0.2 ) \n         parser . set_defaults ( dpml = 1.0 ) \n         parser . set_defaults ( epsilon_design = 6.0 ) \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   init_problem ( self ,   args ):  ``` py3  import   sys  import   argparse  import   numpy   as   np  import   meep   as   mp  from   meep.adjoint   import   ( OptimizationProblem ,   DFTCell ,   adjoint_options , \n                           xHat ,   yHat ,   zHat ,   origin ,   FluxLine , \n                           ParameterizedDielectric ,   FiniteElementBasis )  ##################################################  ##################################################  ##################################################  class   AsymmetricSplitter ( OptimizationProblem ): \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   add_args ( self ,   parser ): \n\n         # add new problem-specific arguments \n         parser . add_argument ( --dair ,          type = float ,   default =- 1.0 ,   help = ) \n         parser . add_argument ( --w_in ,          type = float ,   default = 1.0 ,    help = width of input waveguide ) \n         parser . add_argument ( --w_out1 ,        type = float ,   default = 0.5 ,    help = width of output waveguide 1 ) \n         parser . add_argument ( --w_out2 ,        type = float ,   default = 0.5 ,    help = width of output waveguide 2 ) \n         parser . add_argument ( --l_stub ,        type = float ,   default = 3.0 ,    help = length of waveguide input/output stub ) \n         parser . add_argument ( --l_design ,      type = float ,   default = 2.0 ,    help = length of design region ) \n         parser . add_argument ( --h_design ,      type = float ,   default = 6.0 ,    help = height of design region ) \n         parser . add_argument ( --eps_in ,        type = float ,   default = 6.0 ,    help = input waveguide permittivity ) \n         parser . add_argument ( --eps_out1 ,      type = float ,   default = 2.0 ,    help = output waveguide 1 permittivity ) \n         parser . add_argument ( --eps_out2 ,      type = float ,   default = 12.0 ,   help = output waveguide 2 permittivity ) \n         parser . add_argument ( --nfe ,           type = int ,     default = 2 ,      help = number of finite elements per unit length ) \n\n         # set problem-specific defaults for existing (general) arguments \n         parser . set_defaults ( fcen = 0.5 ) \n         parser . set_defaults ( df = 0.2 ) \n         parser . set_defaults ( dpml = 1.0 ) \n\n     ################################################## \n     ################################################## \n     ################################################## \n     def   init_problem ( self ,   args ): \n\n         #---------------------------------------- \n         # size of computational cell \n         #---------------------------------------- \n         lcen         =   1.0 / args . fcen \n         dpml         =   0.5 * lcen   if   args . dpml ==- 1.0   else   args . dpml \n         dair         =   0.5 * args . w_in   if   args . dair ==- 1.0   else   args . dair \n         sx           =   dpml   +   args . l_stub   +   args . l_design   +   args . l_stub   +   dpml \n         sy           =   dpml   +   dair   +   args . h_design   +   dair   +   dpml \n         cell_size    =   mp . Vector3 ( sx ,   sy ,   0.0 ) \n\n         #---------------------------------------- \n         #- design region \n         #---------------------------------------- \n         design_center   =   origin \n         design_size     =   mp . Vector3 ( args . l_design ,   args . h_design ,   0.0 ) \n         design_region   =   mp . Volume ( center = design_center ,   size = design_size ) \n\n         #---------------------------------------- \n         #- objective regions \n         #---------------------------------------- \n         x_in            =    - 0.5 * ( args . l_design   +   args . l_stub ) \n         x_out           =    + 0.5 * ( args . l_design   +   args . l_stub ) \n         y_out1          =    + 0.25 * args . h_design \n         y_out2          =    - 0.25 * args . h_design \n\n         flux_in         =    FluxLine ( x_in ,       0.0 ,   2.0 * args . w_in ,     mp . X ,   in ) \n         flux_out1       =    FluxLine ( x_out ,   y_out1 ,   2.0 * args . w_out1 ,   mp . X ,   out1 ) \n         flux_out2       =    FluxLine ( x_out ,   y_out2 ,   2.0 * args . w_out2 ,   mp . X ,   out2 ) \n\n         objective_regions    =   [ flux_in ,   flux_out1 ,   flux_out2 ] \n\n         #---------------------------------------- \n         #- optional extra regions for visualization if the --full-dfts options is present. \n         #---------------------------------------- \n         extra_regions        =   [ mp . Volume ( center = origin ,   size = cell_size )]   if   args . full_dfts   else   [] \n\n         #---------------------------------------- \n         # forward source region \n         #---------------------------------------- \n         source_center      =    ( x_in   -   0.25 * args . l_stub ) * xHat \n         source_size        =    2.0 * args . w_in * yHat \n\n         #---------------------------------------- \n         # basis set \n         #---------------------------------------- \n         basis   =   FiniteElementBasis ( args . l_design ,   args . h_design ,   args . nfe ) \n\n         #---------------------------------------- \n         #- objective function \n         #---------------------------------------- \n         fstr   =   (     Abs(P1_out1)**2 \n                  +   +0.0*(P1_out1 + M1_out1) \n                  +   +0.0*(P1_out2 + M1_out2) \n                  +   +0.0*(P1_in   + M1_in + S_out1 + S_out2 + S_in) \n                ) \n\n         #---------------------------------------- \n         #- internal storage for variables needed later \n         #---------------------------------------- \n         self . args              =   args \n         self . dpml              =   dpml \n         self . cell_size         =   cell_size \n         self . basis             =   basis \n         self . design_center     =   origin \n         self . design_size       =   design_size \n         self . source_center     =   source_center \n         self . source_size       =   source_size \n\n         return   fstr ,   objective_regions ,   extra_regions ,   design_region ,   basis \n\n     ############################################################## \n     ############################################################## \n     ############################################################## \n     def   create_sim ( self ,   beta_vector ,   vacuum = False ): \n\n         args = self . args \n         sx = self . cell_size . x \n\n         x_in     =   - 0.5 * ( args . l_design   +   args . l_stub ) \n         x_out    =   + 0.5 * ( args . l_design   +   args . l_stub ) \n         y_out1   =   + 0.25 * args . h_design \n         y_out2   =   - 0.25 * args . h_design \n\n         wvg_in   =   mp . Block (   center = mp . Vector3 ( x_in , 0.0 ), \n                            size = mp . Vector3 ( args . l_stub , args . w_in ), \n                            material = mp . Medium ( epsilon = args . eps_in )) \n         wvg_out1   =   mp . Block (   center = mp . Vector3 ( x_out , y_out1 ), \n                              size = mp . Vector3 ( args . l_stub , args . w_out1 ), \n                              material = mp . Medium ( epsilon = args . eps_out1 )) \n         wvg_out2   =   mp . Block (   center = mp . Vector3 ( x_out , y_out2 ), \n                              size = mp . Vector3 ( args . l_stub , args . w_out2 ), \n                              material = mp . Medium ( epsilon = args . eps_out2 )) \n         design     =   mp . Block (   center = origin , \n                              size = mp . Vector3 ( args . l_design , args . h_design ), \n                              epsilon_func = ParameterizedDielectric ( self . design_center , \n                                                                   self . basis , \n                                                                   beta_vector ) \n                            ) \n\n         geometry = [ wvg_in ,   wvg_out1 ,   wvg_out2 ,   design ] \n\n         envelope   =   mp . GaussianSource ( args . fcen , fwidth = args . df ) \n         amp = 1.0 \n         if   callable ( getattr ( envelope ,   fourier_transform ,   None )): \n             amp   /=   envelope . fourier_transform ( args . fcen ) \n         sources = [ mp . EigenModeSource ( src = envelope , \n                                     center = self . source_center , \n                                     size = self . source_size , \n                                     eig_band = self . args . source_mode , \n                                     amplitude = amp \n                                    ) \n                 ] \n\n         sim = mp . Simulation ( resolution = args . res ,   cell_size = self . cell_size , \n                           boundary_layers = [ mp . PML ( args . dpml )],   geometry = geometry , \n                           sources = sources ) \n\n         if   args . complex_fields : \n             sim . force_complex_fields = True \n\n         return   sim  ######################################################################  # if executed as a script, we look at our own filename to figure out  # the name of the class above, create an instance of this class called  # opt_prob, and call its run() method.  ######################################################################  if   __name__   ==   __main__ : \n     opt_prob = globals ()[ __file__ . split ( / )[ - 1 ] . split ( . )[ 0 ]]() \n     opt_prob . run ()", 
            "title": "Mechanics of meep design optimization"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/", 
            "text": "$$\n   \\newcommand{\\vb}{\\mathbf}\n   \\newcommand{\\wt}{\\widetilde}\n   \\newcommand{\\mc}{\\mathcal}\n   \\newcommand{\\bmc}[1]{\\boldsymbol{\\mathcal{#1}}}\n   \\newcommand{\\sup}[1]{^{\\text{#1}}}\n   \\newcommand{\\sups}[1]{^{\\text{#1}}}\n   \\newcommand{\\sub}[1]{_{\\text{#1}}}\n   \\newcommand{\\subs}[1]{_{\\text{#1}}}\n   \\newcommand{\\pard}[2]{\\frac{\\partial #1}{\\partial #2}}\n   \\newcommand{\\VMV}[3]{ \\Big\\langle #1 \\Big| #2 \\Big| #3 \\Big\\rangle}\n$$\n\n\n\n.superfences-tabs {\n  display: flex;\n  position: relative;\n  flex-wrap: wrap;\n}\n\n.superfences-tabs .highlight {\n  background: #ddd;\n}\n\n.superfences-tabs .superfences-content {\n  display: none;\n  order: 99;\n  width: 100%;\n}\n\n.superfences-tabs label {\n  width: auto;\n  margin: 0 0.5em;\n  padding: 0.25em;\n  font-size: 120%;\n  cursor: pointer;\n}\n\n.superfences-tabs input {\n  position: absolute;\n  opacity: 0;\n}\n\n.superfences-tabs input:nth-child(n+1) {\n  color: #333333;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label {\n    color: #FF5252;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label + .superfences-content {\n    display: block;\n}\n\n\n\n\n\n\nDesign optimization with the \nmeep\n adjoint solver: A reference manual\n\n\n\n\nAs described in the \nOverview\n, the first step in\nusing \nmp.adjoint\n is to write a python script implementing\na subclass of the \nOptimizationProblem\n abstract base class\ndefined by \nmp.adjoint\n. Once that's ready, you can run\nyour script with command-line options instructing \nmp.adjoint\n\nto carry out various calculations; these may be \nsingle-point\n\ncalculations, in which the geometry is fixed at given set\nof values you specify for the design variables (thus defining\na single point in the space of possible input), or full-blown\n\niterative optimizations\n in which \nmp.adjoint\n automatically\nevolves the design variables toward the values that optimize\nyour objective. \n\n\n\n\n \ntable of contents\n\n\n\n\n\n\nDefining your problem\n: Writing a python script for \nmp.adjoint\n\n\na. The \nOptimizationProblem\n abstract base class\n\n\nb. Mandatory class-method overrides: \ninit_problem\n and \ncreate_sim\n\n\nc. Optional class-method override: \nadd_args\n\n\n\n\n\n\nReviewing your problem\n: Visualization and single-point calculations\n\n\na. Visualizing your geometry\n\n\nb. Evaluating the objective function value and gradient at a single\n   design point\n\n\nc. Testing gradient components by finite-differencing\n\n\nd. Running many single-point calculations in parallel:\n   \nParallelDesignTester\n\n\n\n\n\n\nSolving your problem\n: Launching an iterative design optimization\n\n\na. Run your script with \n--optimize\n\n\nb. Options controlling the optimization process\n\n\n\n\n\n\n4. Built-in command-line options\n\n\n\n\n1. Defining your problem: Writing a python script for \nmp.adjoint\n\n\n1a. The \nOptimizationProblem\n abstract base class\n\n\nAs described in the \nOverview\n, the python script\nthat drives your \nmp.adjoint\n session implements a subclass\nof the \nOptimizationProblem\n base class defined by \nmp.adjoint.\n\nThis is a high-level abstraction of the design-automation \nprocess; the base class knows how to do various general things\ninvolving \nmeep\n geometries and objective\nfunctions, but is lacking crucial information from you, \nwithout which it can't do anything on its own.\nThat is to say, \nOptimizationProblem\n is an\n\nabstract base class\n\nwith two pure virtual methods that your derived class\nmust override to describe the specifics of your design problem.\n\n\n1b. Mandatory class-method overrides\n\n\nMore specifically, your subclass of \nOptimizationProblem\n\nmust furnish implementations of the following two pure virtual\nmethods left unimplemented in the base class. (Click the header\nbars to unfold the description of each item.)\n\n\ninit_problem\n: One-time initialization\nYour \ninit_problem\n routine will be called once, at the beginning of a \nmp.adjoint\n\nsession; think of it as the class constructor. (Indeed, it is called from the\nparent class constructor.) \nIt has two purposes: \n(a)\n to give you a chance to complete any one-time initialization\ntasks you need to do, and \n(b)\n to communication to the base class the\n[d\n\n\n\n\n[CommonElementsOfOptimizationGeometries]\n\n\nin which you initialize\n    any problem-specific (but design-independent, i.e. not dependent on particular\n    values of the design variables) initialization needed for your geometry\n    and return some pieces of design-independent data needed by the base class.    \n\n\n- **Calling convention:** `def init_problem(self,args)`\n\n    - `args`: Structure containing values of all command-line options.\n\n- **Return values:**\n    The routine should return a 5-tuple\n   ```py3 fstr, objective_regions, extra_regions, design_region, basis```\n   information\n\n\n\n\n\n\ncreate_sim\n: Instantiating a geometry with given design variables\nYour \ncreate_sim\n routine will be called each time \nmp.adjoint\n needs to\ncompute your objective function for a particular set of design-variable\nvalues.\n\n\n\n\n---\n\n\n1c. Optional class-method override\n\n\n???  summary \"\nadd_args\n: Configure problem-specific command-line arguments\n     The \nOptimizationProblem\n base class defines a\n     \nlarge number of general-purpose command-line options\n,\n     with judiciously chosen default values, to control \nmp.adjoint\n calculations. \n     In many cases you will want \n(1)\n to reconfigure the default values as\n     appropriate for your problem, \n(2)\n to add additional options relevant to\n     your specific geometry. Your subclass can do both of these things by overriding\n     the \nadd_args\n class method, which will be called just before the actual\n     command-line arguments are parsed.\n\n\n **Prototype:**  `init_args(self,parser)`\n     -- `parser`: [`argparse`](https://docs.python.org/3/library/argparse.html)\n                  structure that has been initialized with\n                  [all built-in `mp.adjoint` options](#4-built-in-command-line-options)\n                  and their default values.\n                  You may call `parser.set_defaults` to change the default values of\n                  built-in options and `parser.add_argument` to add new options.\n                  (The actual values specified for all arguments are made available\n                   to you via the `args` parameter passed to your `init_problem`\n                   routine.)\n\n **Return values:**  None.\n\n\n\n\n---\n\n\nDFT cells\n\n\nObjective-function specifications\n\n\nYour objective function is specified by the string \nfstr\n that you return as\nthe first element in the 5-tuple return value of \ninit_problem.\n\n\nYour objective function will depend on one or more objective quantities,\nsuch as power fluxes or eigenmode expansion coefficients, associated\nwith specific objective regions in your geometry. \nmp.adjoint\n defines\na convention for assigning a unique character string to each \nobjective function in your geometry. Your \nfstr\n should use\nthese labels to refer to the objective quantities on which it\ndepends.\n\n\n\n\n \nNaming convention for objective quantities\n\n\n\n\n\n\n\n\nQuantity\n\n\nLabel\n\n\n\n\n\n\n\n\n\n\nPower flux through flux region \nr\n\n\nS_r\n\n\n\n\n\n\nExpansion coefficient for forward-travelling eigenmode \nn\n at flux region \nr\n\n\nPn_r\n\n\n\n\n\n\nExpansion coefficient for backward-travelling eigenmode \nn\n at flux region \nr\n\n\nMn_r\n\n\n\n\n\n\n\n\nNote that the flux-region label \nr\n may be a character string like \neast\n if your \ninit_problem\n \n  method assigned a name to the \nDFTCell\n for that region. Otherwise, \nr\n is an integer-valued\n  index corresponding to the zero-based index of the DFT cell in the \nobjective_regions\n list\n  returned by your \ninit_problem\n.\n\n\n\n\n\n\nExpansion bases \n\n\n2. \nReviewing your problem\n: Visualization and single-point calculations\n\n\n\n\n2a. Visualizing your geometry\n\n\n\n\n2b. Evaluating the objective function value and gradient at a single design point\n\n\njj\nparser.add_argument\n to define new arguments\n\n\n2c. Testing gradient components by finite-differencing\n\n\n\n\n3d. Running many single-point calculations in parallel:\n\n\n     `ParallelDesignTester`\n\n\n\n\n---\n\n\n3. \nSolving your problem\n: Launching an iterative design optimization\n\n\n\n\n3a. Run your script with \n--optimize\n\n\n\n\n3b  Options controlling the optimization process\n\n\n4. Built-in command-line options\n\n\nThe following command-line options are defined by the \nOptimizationProblem\n\nbase class and are available in all \nmp.adjoint\n sessions.\nAs described\n\n\nOptions affecting \nmeep\n timestepping\n\n\n\n\n\n\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n--\nres\n\n\n\n\n\n\n\n\nHello this it the description of that last argument\n\n\n\n\n\n\n\n\n--\nlabel_source_regions\n\n\n\n\n\n\n\n\nand similarly right here foryaf", 
            "title": "Reference Manual"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#design-optimization-with-the-meep-adjoint-solver-a-reference-manual", 
            "text": "As described in the  Overview , the first step in\nusing  mp.adjoint  is to write a python script implementing\na subclass of the  OptimizationProblem  abstract base class\ndefined by  mp.adjoint . Once that's ready, you can run\nyour script with command-line options instructing  mp.adjoint \nto carry out various calculations; these may be  single-point \ncalculations, in which the geometry is fixed at given set\nof values you specify for the design variables (thus defining\na single point in the space of possible input), or full-blown iterative optimizations  in which  mp.adjoint  automatically\nevolves the design variables toward the values that optimize\nyour objective.      table of contents    Defining your problem : Writing a python script for  mp.adjoint  a. The  OptimizationProblem  abstract base class  b. Mandatory class-method overrides:  init_problem  and  create_sim  c. Optional class-method override:  add_args    Reviewing your problem : Visualization and single-point calculations  a. Visualizing your geometry  b. Evaluating the objective function value and gradient at a single\n   design point  c. Testing gradient components by finite-differencing  d. Running many single-point calculations in parallel:\n    ParallelDesignTester    Solving your problem : Launching an iterative design optimization  a. Run your script with  --optimize  b. Options controlling the optimization process    4. Built-in command-line options", 
            "title": "Design optimization with the meep adjoint solver: A reference manual"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#1-defining-your-problem-writing-a-python-script-for-mpadjoint", 
            "text": "", 
            "title": "1. Defining your problem: Writing a python script for mp.adjoint"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#1a-the-optimizationproblem-abstract-base-class", 
            "text": "As described in the  Overview , the python script\nthat drives your  mp.adjoint  session implements a subclass\nof the  OptimizationProblem  base class defined by  mp.adjoint. \nThis is a high-level abstraction of the design-automation \nprocess; the base class knows how to do various general things\ninvolving  meep  geometries and objective\nfunctions, but is lacking crucial information from you, \nwithout which it can't do anything on its own.\nThat is to say,  OptimizationProblem  is an abstract base class \nwith two pure virtual methods that your derived class\nmust override to describe the specifics of your design problem.", 
            "title": "1a. The OptimizationProblem abstract base class"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#1b-mandatory-class-method-overrides", 
            "text": "More specifically, your subclass of  OptimizationProblem \nmust furnish implementations of the following two pure virtual\nmethods left unimplemented in the base class. (Click the header\nbars to unfold the description of each item.)  init_problem : One-time initialization Your  init_problem  routine will be called once, at the beginning of a  mp.adjoint \nsession; think of it as the class constructor. (Indeed, it is called from the\nparent class constructor.) \nIt has two purposes:  (a)  to give you a chance to complete any one-time initialization\ntasks you need to do, and  (b)  to communication to the base class the\n[d   [CommonElementsOfOptimizationGeometries]  in which you initialize\n    any problem-specific (but design-independent, i.e. not dependent on particular\n    values of the design variables) initialization needed for your geometry\n    and return some pieces of design-independent data needed by the base class.      - **Calling convention:** `def init_problem(self,args)`\n\n    - `args`: Structure containing values of all command-line options.\n\n- **Return values:**\n    The routine should return a 5-tuple\n   ```py3 fstr, objective_regions, extra_regions, design_region, basis```\n   information   create_sim : Instantiating a geometry with given design variables Your  create_sim  routine will be called each time  mp.adjoint  needs to\ncompute your objective function for a particular set of design-variable\nvalues.", 
            "title": "1b. Mandatory class-method overrides"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#-", 
            "text": "", 
            "title": "---"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#1c-optional-class-method-override", 
            "text": "???  summary \" add_args : Configure problem-specific command-line arguments\n     The  OptimizationProblem  base class defines a\n      large number of general-purpose command-line options ,\n     with judiciously chosen default values, to control  mp.adjoint  calculations. \n     In many cases you will want  (1)  to reconfigure the default values as\n     appropriate for your problem,  (2)  to add additional options relevant to\n     your specific geometry. Your subclass can do both of these things by overriding\n     the  add_args  class method, which will be called just before the actual\n     command-line arguments are parsed.   **Prototype:**  `init_args(self,parser)`\n     -- `parser`: [`argparse`](https://docs.python.org/3/library/argparse.html)\n                  structure that has been initialized with\n                  [all built-in `mp.adjoint` options](#4-built-in-command-line-options)\n                  and their default values.\n                  You may call `parser.set_defaults` to change the default values of\n                  built-in options and `parser.add_argument` to add new options.\n                  (The actual values specified for all arguments are made available\n                   to you via the `args` parameter passed to your `init_problem`\n                   routine.)\n\n **Return values:**  None.", 
            "title": "1c. Optional class-method override"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#-_1", 
            "text": "", 
            "title": "---"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#dft-cells", 
            "text": "", 
            "title": "DFT cells"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#objective-function-specifications", 
            "text": "Your objective function is specified by the string  fstr  that you return as\nthe first element in the 5-tuple return value of  init_problem.  Your objective function will depend on one or more objective quantities,\nsuch as power fluxes or eigenmode expansion coefficients, associated\nwith specific objective regions in your geometry.  mp.adjoint  defines\na convention for assigning a unique character string to each \nobjective function in your geometry. Your  fstr  should use\nthese labels to refer to the objective quantities on which it\ndepends.     Naming convention for objective quantities     Quantity  Label      Power flux through flux region  r  S_r    Expansion coefficient for forward-travelling eigenmode  n  at flux region  r  Pn_r    Expansion coefficient for backward-travelling eigenmode  n  at flux region  r  Mn_r     Note that the flux-region label  r  may be a character string like  east  if your  init_problem  \n  method assigned a name to the  DFTCell  for that region. Otherwise,  r  is an integer-valued\n  index corresponding to the zero-based index of the DFT cell in the  objective_regions  list\n  returned by your  init_problem .", 
            "title": "Objective-function specifications"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#2-reviewing-your-problem-visualization-and-single-point-calculations", 
            "text": "", 
            "title": "2. Reviewing your problem: Visualization and single-point calculations"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#2a-visualizing-your-geometry", 
            "text": "", 
            "title": "2a. Visualizing your geometry"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#2b-evaluating-the-objective-function-value-and-gradient-at-a-single-design-point", 
            "text": "", 
            "title": "2b. Evaluating the objective function value and gradient at a single design point"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#jjparseradd_argument-to-define-new-arguments", 
            "text": "", 
            "title": "jjparser.add_argument to define new arguments"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#2c-testing-gradient-components-by-finite-differencing", 
            "text": "", 
            "title": "2c. Testing gradient components by finite-differencing"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#3d-running-many-single-point-calculations-in-parallel", 
            "text": "`ParallelDesignTester`", 
            "title": "3d. Running many single-point calculations in parallel:"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#-_2", 
            "text": "", 
            "title": "---"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#3-solving-your-problem-launching-an-iterative-design-optimization", 
            "text": "", 
            "title": "3. Solving your problem: Launching an iterative design optimization"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#3a-run-your-script-with-optimize", 
            "text": "", 
            "title": "3a. Run your script with --optimize"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#3b-options-controlling-the-optimization-process", 
            "text": "", 
            "title": "3b  Options controlling the optimization process"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#4-built-in-command-line-options", 
            "text": "The following command-line options are defined by the  OptimizationProblem \nbase class and are available in all  mp.adjoint  sessions.\nAs described", 
            "title": "4. Built-in command-line options"
        }, 
        {
            "location": "/AdjointSolver/ReferenceManual/#options-affecting-meep-timestepping", 
            "text": "Option  Description      -- res     Hello this it the description of that last argument     -- label_source_regions     and similarly right here foryaf", 
            "title": "Options affecting meep timestepping"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/", 
            "text": "$$\n   \\newcommand{\\vb}{\\mathbf}\n   \\newcommand{\\wt}{\\widetilde}\n   \\newcommand{\\mc}{\\mathcal}\n   \\newcommand{\\bmc}[1]{\\boldsymbol{\\mathcal{#1}}}\n   \\newcommand{\\sup}[1]{^{\\text{#1}}}\n   \\newcommand{\\sups}[1]{^{\\text{#1}}}\n   \\newcommand{\\sub}[1]{_{\\text{#1}}}\n   \\newcommand{\\subs}[1]{_{\\text{#1}}}\n   \\newcommand{\\pard}[2]{\\frac{\\partial #1}{\\partial #2}}\n   \\newcommand{\\VMV}[3]{ \\Big\\langle #1 \\Big| #2 \\Big| #3 \\Big\\rangle}\n$$\n\n\n\n.superfences-tabs {\n  display: flex;\n  position: relative;\n  flex-wrap: wrap;\n}\n\n.superfences-tabs .highlight {\n  background: #ddd;\n}\n\n.superfences-tabs .superfences-content {\n  display: none;\n  order: 99;\n  width: 100%;\n}\n\n.superfences-tabs label {\n  width: auto;\n  margin: 0 0.5em;\n  padding: 0.25em;\n  font-size: 120%;\n  cursor: pointer;\n}\n\n.superfences-tabs input {\n  position: absolute;\n  opacity: 0;\n}\n\n.superfences-tabs input:nth-child(n+1) {\n  color: #333333;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label {\n    color: #FF5252;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label + .superfences-content {\n    display: block;\n}\n\n\n\n\n\n\nDesign optimization with the \nmeep\n adjoint solver: Gallery of worked examples\n\n\n\n\n\n\n \ntable of contents\n\n\n\n\n\n\nFull automated optimization of a cross-router device\n\n\nAn full example of a successful automated design automation in which \nmp.adjoint\n\nautomatically redesigns a photonic component to improve its performance by\nseveral orders of magnitude with no human guidance whatsoever.\n\n\n\n\n\n\nNumerical validation of adjoint gradients\n\n\nA warm-up validation in which we test the accuracy of objective-function derivatives\ncomputed by \nmp.adjoint\n against known results and finite-difference derivatives\nfor a simple toy model.\n\n\n\n\n\n\n\n\nFull automated optimization of a cross-router device\n\n\nIn this example, \nmeep.adjoint\n automatically designs the \ncentral section of a \nfour-way router\n\nto achieve near-perfect routing of power from the \nwest\n input\nport to the \nnorth\n output port.\n\n\n   \ncd\n \n${\nMEEP_INSTALLATION\n}\n/python/examples/adjoint_optimization\n   python CrossRouter.py --verbose --visualize --optimize\n\n\n\n\n\n\n \nIteration Zero: Initial objective-function value \nf_0 = 8.5\\times 10^{-4}\nf_0 = 8.5\\times 10^{-4}\n\n\n\n\n\n\n\n\n\n\n\n\nGeometry\n\n\nForward fields\n\n\nAdjoint derivative \n\\partial f /\\partial\\epsilon\n\\partial f /\\partial\\epsilon\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \nIteration One: Objective-function value \nf_1 = 3.8\\times 10^{-1}\nf_1 = 3.8\\times 10^{-1}\n\n\n\n\n\n\n\n\n\n\nGeometry\n\n\nForward fields\n\n\nAdjoint derivative \n\\partial f /\\partial\\epsilon\n\\partial f /\\partial\\epsilon\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \nAfter 50 Iterations: Objective-function value \nf_1 = 0.9605\nf_1 = 0.9605\n\n\n\n\n\n\n\n\n\n\nGeometry\n\n\nForward fields\n\n\nAdjoint derivative \n\\partial f /\\partial\\epsilon\n\\partial f /\\partial\\epsilon\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \nObjective-function evolution by iteration\n\n  \n\n\n\n\n---\n\n\nNumerical validation of adjoint gradients\n\n\nAs discussed in the \nReference Manual\n,\nthe \nOptimizationProblem\n base class offers command-line options\nfor estimating objective-function derivatives with respect\nto individual design variables---that is, individual components\nof the objective-function gradient vector---by numerical finite-differencing. \nThis provides a useful check on the accuracy of the\ngradient computed via the adjoint method. In this example\nwe'll apply this technique to the simple\n\nholey waveguide\n geometry discussed\nin the [Overview][Overview], involving a circular hole \nin an otherwise perfect section of a slab waveguide of\npermittivity \n\\epsilon\\sups{wvg}\n\\epsilon\\sups{wvg}\n.\nFor this problem, the design region is the area of the hole,\nand we will consider a particularly simple basis consisting of\nthe single basis function \n\\{b_0(\\vb x)\\equiv 1\\}\n\\{b_0(\\vb x)\\equiv 1\\}\n, so that\nour sole design variable \n\\beta_0\n\\beta_0\n is just the constant permittivity$\n\n\\epsilon\\sups{hole}\n\\epsilon\\sups{hole}\n of the hole region; the design problem is\nto tweak \n\\epsilon\\sups{hole}\n\\epsilon\\sups{hole}\n \nto maximize output power flux (flux through the port labeled 'east') \nfor fixed input flux from by the eigenmode source2.\n\n\nThe advantage of this as a validating sanity-check for\nadjoint calculations is the simple dependence \nof the objective on the design variable:\nclearly, transmission through the waveguides can't\nbe better than perfect, which is what it is\nwhen $\\epsilon\\sups{hole}\\equiv \\epsilon\\sups{wvg}\nand there \\textit{is} no hole, so \nthe function \nf(\\epsilon\\sup{hole})\nf(\\epsilon\\sup{hole})\n must\nbe peaked at \n\\epsilon\\sup{wvg}\n\\epsilon\\sup{wvg}\n and its\nderivative vanishes there. This gives one\ntest on the correctness of an adjoint implementation,\nand we get others by looking at the derivative\nat other points on the curve, with reference values\nbe estimated via finite-differencing.\n\n\nThus, for a set of 24 \n\\epsilon^\\subs{hole}\n\\epsilon^\\subs{hole}\n values\nranging from 1 to \n2\\epsilon^\\sup{wvg}\n2\\epsilon^\\sup{wvg}\n we will\ncompute the objective function and its adjoint-based \nand finite-difference derivatives with respect to\n\n\\epsilon\\sups{hole}\n\\epsilon\\sups{hole}\n.\n\n\nRunning the calculation serially from a shell script\n\n\nThe individual calculations may be performed by executing the\n[\nHoleyWaveguide.py\n][\nHoleyWaveyguide.py\n] script from the\nshell with command-line options, i.e.\n\n\n#!/bin/bash\n\n\npython HoleyWaveguide.py \n${\nCOMMON\n}\n --beta \n0\n  \n1\n.0 --filebase B1P0\npython HoleyWaveguide.py \n${\nCOMMON\n}\n --beta \n0\n  \n1\n.5 --filebase B1P5\npython HoleyWaveguide.py \n${\nCOMMON\n}\n --beta \n0\n  \n2\n.0 --filebase B120\n...\npython HoleyWaveguide.py \n${\nCOMMON\n}\n --beta \n0\n \n12\n.0 --filebase BW12P0\n\n\n\n\nNote that the only options that vary from case to case\nare \n--beta 0 xx\n, setting distinct values for the design\nvariable \n\\beta_0\\equiv \\epsilon\\sups{hole}\n\\beta_0\\equiv \\epsilon\\sups{hole}\n,\nand \n--filebase,\n giving different names to output\nfiles so they don't overwrite one another.\nThe options in common to all cases are:\n\n\n### Running the calculation serially from Python\n\n\nThe effect of running the shell \ncommand\n\n\n`\n% python HoleyWaveguide.py OPTIONS\n`\n\ncan be reproduced from a python script or console\nby creating an instance of \n`\nHoleyWaveguide\n`\n\nand calling its \n`\nrun\n()\n`\n method.\nIn this \ncase\n, the command-line options OPTIONS\nshould be passed \n(\nas a single string separated by spaces\n)\n\nto the optional \n`\ncmdline\n`\n parameter of the \n`\nHoleyWaveguide\n`\n\nconstructor, \nwhile\n \n`\nrun\n()\n`\n takes no arguments:\n\n\n```\npy3\nimport numpy as np\n\n\n# generate command lines\n\n\nbs\n \n=\n np.linspace\n(\n1\n.0,12.0,23\n)\n\n\nargs\n \n=\n \n --eval_gradient --fd_order 2 --fd_index 0 \n\n\ncmdlines\n \n=\n \n[\n args + \n--beta 0 {} --filebase b{}\n.format\n(\nb,b\n)\n \nfor\n b in bs \n]\n\n\n\n# run calculations \n\n\nfor\n cmdline in cmdlines:\n    \nHW\n=\nHoleyWaveguide\n(\ncmdline\n=\ncmdline\n)\n    \n    HW.run\n()\n\n\n\n\n\nRunning the calculation\n\n\nHere's how the \n\n\nRunning the calculation in parallel using \nParallelDesignTester\n\n\nAlthough these calculations aren't particularly time-consuming,\nin a multiprocessor environment\nwe can make them go \nreally\n fast by using the \nParallelDesignTester\n\nutility distributed with \nmeep.adjoint\n. As described in the\n[Reference Manual][ParallelDesignTester], this is a simple\ntool provided by \nmeep.adjoint parallel batch processing of jobs \nlike the one considered here, which has the advantage of\npresenting as a completely transparent drop-in replacement\nfor your existing serial loop: \nthe\nentirety\nof the rejiggering required to parallelize\nyour batch is to replace the\nfor cmdline in cmdlines` loop \nabove with the single line\n\n\nParallelDesignTester\n(\nHoleyWaveguide\n,\ncmdlines\n)\n.\nlaunch\n()\n\n\n\n\n\nThis will launch a pool of \nN\nN\n server processes to whittle\nits way in parallel through your batch; for each string\nin the \ncmdlines\n list, one or another server will\ninstantiate a \nHoleyWaveguide\n (or any other class you\nspecify) with those command lines, then call its \nrun()\n\nmethod. \n\n\nResults\n\n\nWhether executed serially or in parallel, each of the 23 jobs\nproduces text-based output files named e.g. \nb13.out\n, \nb13.digest,\n\nand \nb13.legend\n, where \nb13\n is the job-dependent\nlabel assigned the \nfilebase\n option. The \nout\n\nfile uses a compressed format in which all data \n(objective-function values, adjoint gradient values, \nand finite-difference derivatives) for a specific design\npoint (in this case, that means a specific value of \n\n\\beta_0\\equiv \\epsilon\\sups{hole}\n\\beta_0\\equiv \\epsilon\\sups{hole}\n) appear on a single\nline of the file with labels to indicate the design point;\nthis is indended for plotting vs. \n\\beta_0\n\\beta_0\n or other\npost-processing. The \ndigest\n file reports the same\ndata in a more human-readable format.  The \nlegend\n\nfile contains information helping to interpret the content\nof the other files.\n\n\n!!! note \"Working directories in \nParallelDesignTester\n runs\n    \nParallelDesignTester\n creates and changes to a new \n    timestamped working directory for each pool of parallel\n    batch jobs; look for your output files in\n    subdirectory called something like \nHoleyWaveguide_0323.022256,\n\n\nFor the case at hand, we want to \n(a)\n concatenate all of the\n\n.out\n files into an omnibus data file, \n(b)\n sort by the \ndesign-variable values reported on specific columns, then\n\n plot various data quantities (e.g. objective-function \nvalue, adjoint gradient components, and finite-difference derivatives, \neach of which appear in their own specific columns)\nversus design variable.\n\n\n![HoleyWaveguideAdjointVsFDResults][HoleyWaveguide_AdjointVsFD.png]\n\n\nWe see that \n\\epsilon\\sup{hole}\n\\epsilon\\sup{hole}\n derivatives computed by\nadjoints agree well with numerical finite-difference data.", 
            "title": "Example Gallery"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/#design-optimization-with-the-meep-adjoint-solver-gallery-of-worked-examples", 
            "text": "table of contents    Full automated optimization of a cross-router device  An full example of a successful automated design automation in which  mp.adjoint \nautomatically redesigns a photonic component to improve its performance by\nseveral orders of magnitude with no human guidance whatsoever.    Numerical validation of adjoint gradients  A warm-up validation in which we test the accuracy of objective-function derivatives\ncomputed by  mp.adjoint  against known results and finite-difference derivatives\nfor a simple toy model.", 
            "title": "Design optimization with the meep adjoint solver: Gallery of worked examples"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/#full-automated-optimization-of-a-cross-router-device", 
            "text": "In this example,  meep.adjoint  automatically designs the \ncentral section of a  four-way router \nto achieve near-perfect routing of power from the  west  input\nport to the  north  output port.      cd   ${ MEEP_INSTALLATION } /python/examples/adjoint_optimization\n   python CrossRouter.py --verbose --visualize --optimize     Iteration Zero: Initial objective-function value  f_0 = 8.5\\times 10^{-4} f_0 = 8.5\\times 10^{-4}       Geometry  Forward fields  Adjoint derivative  \\partial f /\\partial\\epsilon \\partial f /\\partial\\epsilon               Iteration One: Objective-function value  f_1 = 3.8\\times 10^{-1} f_1 = 3.8\\times 10^{-1}      Geometry  Forward fields  Adjoint derivative  \\partial f /\\partial\\epsilon \\partial f /\\partial\\epsilon               After 50 Iterations: Objective-function value  f_1 = 0.9605 f_1 = 0.9605      Geometry  Forward fields  Adjoint derivative  \\partial f /\\partial\\epsilon \\partial f /\\partial\\epsilon               Objective-function evolution by iteration", 
            "title": "Full automated optimization of a cross-router device"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/#-", 
            "text": "", 
            "title": "---"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/#numerical-validation-of-adjoint-gradients", 
            "text": "As discussed in the  Reference Manual ,\nthe  OptimizationProblem  base class offers command-line options\nfor estimating objective-function derivatives with respect\nto individual design variables---that is, individual components\nof the objective-function gradient vector---by numerical finite-differencing. \nThis provides a useful check on the accuracy of the\ngradient computed via the adjoint method. In this example\nwe'll apply this technique to the simple holey waveguide  geometry discussed\nin the [Overview][Overview], involving a circular hole \nin an otherwise perfect section of a slab waveguide of\npermittivity  \\epsilon\\sups{wvg} \\epsilon\\sups{wvg} .\nFor this problem, the design region is the area of the hole,\nand we will consider a particularly simple basis consisting of\nthe single basis function  \\{b_0(\\vb x)\\equiv 1\\} \\{b_0(\\vb x)\\equiv 1\\} , so that\nour sole design variable  \\beta_0 \\beta_0  is just the constant permittivity$ \\epsilon\\sups{hole} \\epsilon\\sups{hole}  of the hole region; the design problem is\nto tweak  \\epsilon\\sups{hole} \\epsilon\\sups{hole}  \nto maximize output power flux (flux through the port labeled 'east') \nfor fixed input flux from by the eigenmode source2.  The advantage of this as a validating sanity-check for\nadjoint calculations is the simple dependence \nof the objective on the design variable:\nclearly, transmission through the waveguides can't\nbe better than perfect, which is what it is\nwhen $\\epsilon\\sups{hole}\\equiv \\epsilon\\sups{wvg}\nand there \\textit{is} no hole, so \nthe function  f(\\epsilon\\sup{hole}) f(\\epsilon\\sup{hole})  must\nbe peaked at  \\epsilon\\sup{wvg} \\epsilon\\sup{wvg}  and its\nderivative vanishes there. This gives one\ntest on the correctness of an adjoint implementation,\nand we get others by looking at the derivative\nat other points on the curve, with reference values\nbe estimated via finite-differencing.  Thus, for a set of 24  \\epsilon^\\subs{hole} \\epsilon^\\subs{hole}  values\nranging from 1 to  2\\epsilon^\\sup{wvg} 2\\epsilon^\\sup{wvg}  we will\ncompute the objective function and its adjoint-based \nand finite-difference derivatives with respect to \\epsilon\\sups{hole} \\epsilon\\sups{hole} .", 
            "title": "Numerical validation of adjoint gradients"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/#running-the-calculation-serially-from-a-shell-script", 
            "text": "The individual calculations may be performed by executing the\n[ HoleyWaveguide.py ][ HoleyWaveyguide.py ] script from the\nshell with command-line options, i.e.  #!/bin/bash \n\npython HoleyWaveguide.py  ${ COMMON }  --beta  0    1 .0 --filebase B1P0\npython HoleyWaveguide.py  ${ COMMON }  --beta  0    1 .5 --filebase B1P5\npython HoleyWaveguide.py  ${ COMMON }  --beta  0    2 .0 --filebase B120\n...\npython HoleyWaveguide.py  ${ COMMON }  --beta  0   12 .0 --filebase BW12P0  Note that the only options that vary from case to case\nare  --beta 0 xx , setting distinct values for the design\nvariable  \\beta_0\\equiv \\epsilon\\sups{hole} \\beta_0\\equiv \\epsilon\\sups{hole} ,\nand  --filebase,  giving different names to output\nfiles so they don't overwrite one another.\nThe options in common to all cases are:  ### Running the calculation serially from Python \n\nThe effect of running the shell  command  ` % python HoleyWaveguide.py OPTIONS ` \ncan be reproduced from a python script or console\nby creating an instance of  ` HoleyWaveguide ` \nand calling its  ` run () `  method.\nIn this  case , the command-line options OPTIONS\nshould be passed  ( as a single string separated by spaces ) \nto the optional  ` cmdline `  parameter of the  ` HoleyWaveguide ` \nconstructor,  while   ` run () `  takes no arguments: ``` py3\nimport numpy as np # generate command lines  bs   =  np.linspace ( 1 .0,12.0,23 )  args   =    --eval_gradient --fd_order 2 --fd_index 0   cmdlines   =   [  args +  --beta 0 {} --filebase b{} .format ( b,b )   for  b in bs  ]  # run calculations   for  cmdline in cmdlines:\n     HW = HoleyWaveguide ( cmdline = cmdline )     \n    HW.run ()", 
            "title": "Running the calculation serially from a shell script"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/#running-the-calculation", 
            "text": "Here's how the", 
            "title": "Running the calculation"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/#running-the-calculation-in-parallel-using-paralleldesigntester", 
            "text": "Although these calculations aren't particularly time-consuming,\nin a multiprocessor environment\nwe can make them go  really  fast by using the  ParallelDesignTester \nutility distributed with  meep.adjoint . As described in the\n[Reference Manual][ParallelDesignTester], this is a simple\ntool provided by  meep.adjoint parallel batch processing of jobs \nlike the one considered here, which has the advantage of\npresenting as a completely transparent drop-in replacement\nfor your existing serial loop: \nthe entirety of the rejiggering required to parallelize\nyour batch is to replace the for cmdline in cmdlines` loop \nabove with the single line  ParallelDesignTester ( HoleyWaveguide , cmdlines ) . launch ()   This will launch a pool of  N N  server processes to whittle\nits way in parallel through your batch; for each string\nin the  cmdlines  list, one or another server will\ninstantiate a  HoleyWaveguide  (or any other class you\nspecify) with those command lines, then call its  run() \nmethod.", 
            "title": "Running the calculation in parallel using ParallelDesignTester"
        }, 
        {
            "location": "/AdjointSolver/ExampleGallery/#results", 
            "text": "Whether executed serially or in parallel, each of the 23 jobs\nproduces text-based output files named e.g.  b13.out ,  b13.digest, \nand  b13.legend , where  b13  is the job-dependent\nlabel assigned the  filebase  option. The  out \nfile uses a compressed format in which all data \n(objective-function values, adjoint gradient values, \nand finite-difference derivatives) for a specific design\npoint (in this case, that means a specific value of  \\beta_0\\equiv \\epsilon\\sups{hole} \\beta_0\\equiv \\epsilon\\sups{hole} ) appear on a single\nline of the file with labels to indicate the design point;\nthis is indended for plotting vs.  \\beta_0 \\beta_0  or other\npost-processing. The  digest  file reports the same\ndata in a more human-readable format.  The  legend \nfile contains information helping to interpret the content\nof the other files.  !!! note \"Working directories in  ParallelDesignTester  runs\n     ParallelDesignTester  creates and changes to a new \n    timestamped working directory for each pool of parallel\n    batch jobs; look for your output files in\n    subdirectory called something like  HoleyWaveguide_0323.022256,  For the case at hand, we want to  (a)  concatenate all of the .out  files into an omnibus data file,  (b)  sort by the \ndesign-variable values reported on specific columns, then  plot various data quantities (e.g. objective-function \nvalue, adjoint gradient components, and finite-difference derivatives, \neach of which appear in their own specific columns)\nversus design variable.  ![HoleyWaveguideAdjointVsFDResults][HoleyWaveguide_AdjointVsFD.png]  We see that  \\epsilon\\sup{hole} \\epsilon\\sup{hole}  derivatives computed by\nadjoints agree well with numerical finite-difference data.", 
            "title": "Results"
        }, 
        {
            "location": "/AdjointSolver/Visualization/", 
            "text": "$$\n   \\newcommand{\\vb}{\\mathbf}\n   \\newcommand{\\wt}{\\widetilde}\n   \\newcommand{\\mc}{\\mathcal}\n   \\newcommand{\\bmc}[1]{\\boldsymbol{\\mathcal{#1}}}\n   \\newcommand{\\sup}[1]{^{\\text{#1}}}\n   \\newcommand{\\sups}[1]{^{\\text{#1}}}\n   \\newcommand{\\sub}[1]{_{\\text{#1}}}\n   \\newcommand{\\subs}[1]{_{\\text{#1}}}\n   \\newcommand{\\pard}[2]{\\frac{\\partial #1}{\\partial #2}}\n   \\newcommand{\\VMV}[3]{ \\Big\\langle #1 \\Big| #2 \\Big| #3 \\Big\\rangle}\n$$\n\n\n\n.superfences-tabs {\n  display: flex;\n  position: relative;\n  flex-wrap: wrap;\n}\n\n.superfences-tabs .highlight {\n  background: #ddd;\n}\n\n.superfences-tabs .superfences-content {\n  display: none;\n  order: 99;\n  width: 100%;\n}\n\n.superfences-tabs label {\n  width: auto;\n  margin: 0 0.5em;\n  padding: 0.25em;\n  font-size: 120%;\n  cursor: pointer;\n}\n\n.superfences-tabs input {\n  position: absolute;\n  opacity: 0;\n}\n\n.superfences-tabs input:nth-child(n+1) {\n  color: #333333;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label {\n    color: #FF5252;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label + .superfences-content {\n    display: block;\n}\n\n\n\n\n\n\nmeep.adjoint.Visualization\n:\n\n\nEasy, standardized \npymeep\n visualization routines\n\n\nthat \njust work\n\n\n\n\nThe \nmeep.adjoint\n python module implementing\n\nmeep\n adjoint solver includes\nan extensive set of tools for graphical visualization\nof \nmeep\n sessions via\n\nmatplotlib\n.\nAlthough these tools are packaged with and used by\n\nmeep.adjoint\n, they are independent of the adjoint solver\nand can be used for convenient visualization of \nany\n python-driven\n\nmeep\n session---indeed, it is a specific\ngoal of the module that the visualization routines can\nbe invoked, with no arguments, on any \nmeep\n geometry\nand will do something reasonable and useful in every case.\n\n\nThese and other objectives of the initiative are described in the\nfirst section below, after which we present examples to illustrate\nthe three key types of plot produced by the module and how the \ndefault options can be customized.\n\n\n\n\n \ntable of contents\n\n\n\n\n\n\nMotivation and Philsophy\n\n\na,b. \n(a couple of longer-winded discussions culminating in) the\n\n\nc.   \nThe motivating desiderata for \nmeep.adjoint.Visualization\n\n\n\n\n\n\nEasy visualization of simulation geometries before timestepping: \nvisualize_sim\n\n\n\n\n\n\nEasy real-time animation of time-domain fields during \n     \nmeep\n computations:\nAFEClient\n and \nAFEServer\n\n\n\n\n\n\nEasy visualization of frequency-domain fields---in isolation or\n     superposed atop your material geometry\n\n\n\n\n\n\nCustomization:\n*\n\n\n\n\n\n\n\n\n\nMotivation and philosophy\n\n\n\n\n Skip down to the \ntl;dr\n version\n \n    of the motivation and goals of this initiative,\n    or click to expand the tabs below for a\n    longer-winder account.\n\n\n\n\nThe error-checking power of visual sanity checks for text-defined geometries\n\n\nThe fact that every aspect of a \nmeep\n\n   calculation---from the\n  \nmaterial geometry\n,\n  to the \nabsorbing boundaries\n,\n  to the placement and orientation\n  of the \nsources\n,\n  to the positions and sizes of the\n  \nflux monitors\n---is\n  defined by lines of text in script files offers a welcome\n  change of pace from the immersive GUI experience of commercial\n  CAD tools, as well as a natural platform for complex,\n  0ustomized calculations that would be unwieldy or impossible\n  to launch from a point-and-click pull-down interface.\n  Nonetheless, as convenient as it is to specify geometries\n  non-graphically, it's \nalso\n quite useful---arguably even\n  \nessential\n---to review a graphical representation\n  of the geometry you input as interpreted by\n  \nmeep\n, both to confirm that your input\n  was processed as you expected and to catch the sorts of\n  inadvertent errors---a flux monitor in the wrong place,\n  a source pointing the wrong direction---that are\n  all too easy to overlook in your python script,\n  but instantly obvious upon visual inspection.\n\n\n\n\nIn addition to the usefulness of visual sanity checks\n  on your input geometry, it can be helpful to look at\n  graphical visualizations of the electric and magnetic \n  fields computed by \nmeep\n---both\n  the time-domain and the frequency-domain fields---and\n  in particular to review how the field distributions \n  evolve in space in the presence of your material geometry.\n  This is true even though, in many cases, the ultimate\n  desired output of your calculation will be non-graphical,\n  sucha a number---a power flux, an eigenmode coefficient, \n  etc---whose computation, again, will be described by\n  lines of text you write in a script file. If the calculation\n  works correctly as you wrote it and you get \n  a reasonable numerical output on your first try,\n  well, bully for you! You have no need of graphical\n  visualization aids. For the rest of us---who can't\n  figure out why our flux is 10 orders of magnitude \n  too small until we look at the time-domain power flow and\n  realize we set things up backward, so that all the \n  excitation power flows promptly \nout of\n, not into,\n  the computational cell---visualization tools can be \n  a lifesaver.\n\n\n\n\nWait, isn't this a solved problem?\n\n\nSo we're agreed that visualization---of both inputs (geometries)\n  and outputs (fields)---is a good thing. But isn't this a \n  solved problem? After all, \nmeep\n offers\n  plenty of routines for retrieving as much raw data on\n  geometries and fields as any user could want---and, once one\n  has the raw data, it's just a matter of choosing from among the \n  infinitude of available tools for plotting and visualization.\n  Indeed, already within the \nmeep\n documentation\n  itself one can find many different types of visualization generated \n  by many different types of tool. What more is left to say?\n\n\n??? note Wanted: Quick, easy, \nstandard\n visualization paradigms that \njust work\n on any geometry\n    Despite the arguably non-issue status of the situation, I would argue\n    that the current situation is suboptimal in at least two ways.\n    + \n(a)\n The absence of a single, canonical solution means that, as a \nmeep\n user,\n    every time you feel the urge to visualize something you have to spend some time and effort\n    figuring out how you are going to do it---and then going through the hassle of setting that up.\n    In my experience, this was especially true when it came to making movies of the evolution\n    time-domain fields---although the problem had been solved with documentation a couple of times\n    in the manual, still somehow it felt like a major chore to set this up every time\n    I wanted it.\n    + \n(b)\n On a different note, the absence of generally-accepted visualization protocols\n    means that everybody's visualizations look different. This is not necessarily tragic, and\n    we wouldn't want to enforce sterile conformity, but it might be nice if there were \nsome\n\n    notion of \"canonical \nmeep\n visualization format\" to serve as a common\n    language.\n\n\n The motivating desiderata for \nmeep.adjoint.Visualization\n\n  With all of that by way of backstory, here were the guidelines that motivated\n  the design of these routines.\n\n\n\n\n\n\nThey should fully address the three everyday situations that cry out most\n    urgently for visualization support\n,' namely\n\n\n\n\n\n\nSimulation geometry before timestepping.\n A static image of the simulation geometry at the begininng of the calculation, \n      before timestepping has begun. The important targets for visualization are the following items and their \n      relative positioning vis-a-vis one another: \n(a)\n the material geometry, \n(b)\n the absorbers,\n      \n the location and nature of sources, \n(d)\n the position and size of any DFT cells in which\n      frequency-domain fields are to be computed.\n\n\n\n\n\n\nTime-domain fields during timestepping.\n An animation or movie showing the time-domain fields evolving\n      throughout the timestepping. For one thing, this tells you instantly when you have e.g. oriented your\n      source backwards or otherwise misconfigured something obvious---you sit and watch all of \n      your \"input\" power go flying right out of the cell to the left instead of proceeding rightward \n      into the center like you intended---whereas the \nfrequency\n-domain plots produced even by \n      such totally misbegotten simulations can be pretty effective at obscuring even obvious\n      culprits.\n      Also, after all, the ability to observe essentially time-domain phenomena is one of the\n      key reasons to use an FDTD tool in the first place; many frequency-domain problems\n      can be solved much more efficiently by frequency-domain solvers than by something like\n      \nmeep\n, but they don't produce nice movies showing e.g.\n      reflection and diffraction of wave packets from interfaces. So it seems particularly\n      appropriate for a time-domain-solver like \nmeep\n to offer\n      built-in functionality for animating time-domain field evolutions.\n\n\n\n\n\n\n_ \nFrequency-domain fields after timestepping.\n A static image showing the amplitudes of frequency-domain fields\n    in regions of DFT cells, with the spatial distributiono of Poynting flux plotted for DFT flux cells.\n\n\n\n\n\n\nA central goal of this module is to provide reliable, easy-to-use routines for\n     each of these purposes.\n\n\n\n\nThey should offer a hierarchy of customizability options\n for users at different\n   places on the willingness-to-suffer-for-their-art spectrum.\n   Of course, the goals outlined above---routines that are \neasy to use\n and \njust work\n---suggest\n   an implementation strategy in which the tools make all the artistic decisions for you; the easiest\n   calling convention to remember is the one with no parameters. However, one of the nice things\n   about the \nmatplotlib\n backend is how very \nextremely\n\n   customizable it is, and it shouldn't be hard to pass at least some of those options\n   on to users of \nmeep.adjoint.Visualization.\n \n   In view of these considerations, the goal of the routines is to offer\n   a three-tiered hierarchy of customizability levels.\n\n\n\n\na. *\nThe zero-effort calling model for lazy forgetful slackers *\n\n\nFor users who can't be bothered to memorize or look up library function\n   prototypes---or who just want quick and dirty visualization at the\n   prototyping stage with the option to clean up later---it should be \n   possible to call the visualization routines on just the \nsimulation\n \n   entity alone \nwith no configuration arguments whatsoever,\n\n   with the module making reasonable choices to produce helpful graphics \n   in a standardized format.\n\n\nb. **Minimal-effort calling model for the slightly more motivated**\nFor users who fall basically into the previous bucket but are\nmotivated to change one or another option that otherwise\nobstructs the visualization (like, label font size too large),\nthere should be an easy way to configure global settings once,\nafter which the user can proceed lazily to call all visualization\nroutines with no customization arguments.\n\nc. **Full-customization calling model for diligent nitpickers:**\nFinally, for users who *do* want to invest time and effort to \nconfigure plotting options to their liking, the visualization\nmodule should provide copious customization options to allow\nas much as possible of the visualization to be customized.\n\n\n\n\n2. \nEasy visualization of simulation geometries before timestepping: \nvisualize_sim\n\n\nAs described above, the first visualization task we consider\nis that of double-checking the various geometric inputs\nsupplied to \npymeep\n when creating a \n\nsimulation\n:\nthe computational cell and material geometry, the absorbing boundaries, the exciting sources, \nand any DFT cells for which we requested tabulation of frequency-domain fields. Also described\nabove was the imperative that, to ensure a maximally memorable calling convention,\n the visualization routine be callable on *just the \nsimulation\n class itself with no\nother parameters required.\nThese objectives are satisfied by the\nvisualize_sim\nroutine in\nmeep.adjoint.Visualization\n,\nwhose calling convention is precision-engineered to be as painless as possible: after\ncreating a \nspan class=SC\npymeep\n/sc\nsimulation\n/sc\n\nthrough by a call like\n#!py3 sim=mp.simulation(geometry=...)`, \nyou can simply say\n\n\n  \nvisualize_sim\n(\nsim\n)\n\n\n\n\n\nand voil\u00e0! A new plot window sprouts open to reveal your simulation\nin all its glory, looking something like this:\n\n\n\n\n![\n\n\n\n\nas one example, here's what \nvisualize_sim\n\nproduces for the \nHole Cloak\n\nexample discussed in the adjoint-solver documentation:\n```\n\n\nTrue to form, the visualization function for this scenario\n\n\n(although there are many \noptional\n parameters \nde\n\n\nAll of this information is presented in graphical\nform\n\n\nDuring timestepping: Real-time visualization of time-domain field evolution\n\n\nspl\nTo support this, \nmeep.adjoint.Visualization\n defines a new\n\nstep function\n\nthat you can pass to the\n[run function][RunFunctions] you use\nto drive timestepping.\n\n\nAfter timestepping: Visualizing frequency-domain Poynting fluxes and energy densities", 
            "title": "Visualization"
        }, 
        {
            "location": "/AdjointSolver/Visualization/#meepadjointvisualization", 
            "text": "", 
            "title": "meep.adjoint.Visualization:"
        }, 
        {
            "location": "/AdjointSolver/Visualization/#easy-standardized-pymeep-visualization-routines", 
            "text": "", 
            "title": "Easy, standardized pymeep visualization routines"
        }, 
        {
            "location": "/AdjointSolver/Visualization/#that-just-work", 
            "text": "The  meep.adjoint  python module implementing meep  adjoint solver includes\nan extensive set of tools for graphical visualization\nof  meep  sessions via matplotlib .\nAlthough these tools are packaged with and used by meep.adjoint , they are independent of the adjoint solver\nand can be used for convenient visualization of  any  python-driven meep  session---indeed, it is a specific\ngoal of the module that the visualization routines can\nbe invoked, with no arguments, on any  meep  geometry\nand will do something reasonable and useful in every case.  These and other objectives of the initiative are described in the\nfirst section below, after which we present examples to illustrate\nthe three key types of plot produced by the module and how the \ndefault options can be customized.     table of contents    Motivation and Philsophy  a,b.  (a couple of longer-winded discussions culminating in) the  c.    The motivating desiderata for  meep.adjoint.Visualization    Easy visualization of simulation geometries before timestepping:  visualize_sim    Easy real-time animation of time-domain fields during \n      meep  computations: AFEClient  and  AFEServer    Easy visualization of frequency-domain fields---in isolation or\n     superposed atop your material geometry    Customization: *", 
            "title": "that just work"
        }, 
        {
            "location": "/AdjointSolver/Visualization/#motivation-and-philosophy", 
            "text": "Skip down to the  tl;dr  version  \n    of the motivation and goals of this initiative,\n    or click to expand the tabs below for a\n    longer-winder account.   The error-checking power of visual sanity checks for text-defined geometries  The fact that every aspect of a  meep \n   calculation---from the\n   material geometry ,\n  to the  absorbing boundaries ,\n  to the placement and orientation\n  of the  sources ,\n  to the positions and sizes of the\n   flux monitors ---is\n  defined by lines of text in script files offers a welcome\n  change of pace from the immersive GUI experience of commercial\n  CAD tools, as well as a natural platform for complex,\n  0ustomized calculations that would be unwieldy or impossible\n  to launch from a point-and-click pull-down interface.\n  Nonetheless, as convenient as it is to specify geometries\n  non-graphically, it's  also  quite useful---arguably even\n   essential ---to review a graphical representation\n  of the geometry you input as interpreted by\n   meep , both to confirm that your input\n  was processed as you expected and to catch the sorts of\n  inadvertent errors---a flux monitor in the wrong place,\n  a source pointing the wrong direction---that are\n  all too easy to overlook in your python script,\n  but instantly obvious upon visual inspection.   In addition to the usefulness of visual sanity checks\n  on your input geometry, it can be helpful to look at\n  graphical visualizations of the electric and magnetic \n  fields computed by  meep ---both\n  the time-domain and the frequency-domain fields---and\n  in particular to review how the field distributions \n  evolve in space in the presence of your material geometry.\n  This is true even though, in many cases, the ultimate\n  desired output of your calculation will be non-graphical,\n  sucha a number---a power flux, an eigenmode coefficient, \n  etc---whose computation, again, will be described by\n  lines of text you write in a script file. If the calculation\n  works correctly as you wrote it and you get \n  a reasonable numerical output on your first try,\n  well, bully for you! You have no need of graphical\n  visualization aids. For the rest of us---who can't\n  figure out why our flux is 10 orders of magnitude \n  too small until we look at the time-domain power flow and\n  realize we set things up backward, so that all the \n  excitation power flows promptly  out of , not into,\n  the computational cell---visualization tools can be \n  a lifesaver.   Wait, isn't this a solved problem?  So we're agreed that visualization---of both inputs (geometries)\n  and outputs (fields)---is a good thing. But isn't this a \n  solved problem? After all,  meep  offers\n  plenty of routines for retrieving as much raw data on\n  geometries and fields as any user could want---and, once one\n  has the raw data, it's just a matter of choosing from among the \n  infinitude of available tools for plotting and visualization.\n  Indeed, already within the  meep  documentation\n  itself one can find many different types of visualization generated \n  by many different types of tool. What more is left to say?  ??? note Wanted: Quick, easy,  standard  visualization paradigms that  just work  on any geometry\n    Despite the arguably non-issue status of the situation, I would argue\n    that the current situation is suboptimal in at least two ways.\n    +  (a)  The absence of a single, canonical solution means that, as a  meep  user,\n    every time you feel the urge to visualize something you have to spend some time and effort\n    figuring out how you are going to do it---and then going through the hassle of setting that up.\n    In my experience, this was especially true when it came to making movies of the evolution\n    time-domain fields---although the problem had been solved with documentation a couple of times\n    in the manual, still somehow it felt like a major chore to set this up every time\n    I wanted it.\n    +  (b)  On a different note, the absence of generally-accepted visualization protocols\n    means that everybody's visualizations look different. This is not necessarily tragic, and\n    we wouldn't want to enforce sterile conformity, but it might be nice if there were  some \n    notion of \"canonical  meep  visualization format\" to serve as a common\n    language.   The motivating desiderata for  meep.adjoint.Visualization \n  With all of that by way of backstory, here were the guidelines that motivated\n  the design of these routines.    They should fully address the three everyday situations that cry out most\n    urgently for visualization support ,' namely    Simulation geometry before timestepping.  A static image of the simulation geometry at the begininng of the calculation, \n      before timestepping has begun. The important targets for visualization are the following items and their \n      relative positioning vis-a-vis one another:  (a)  the material geometry,  (b)  the absorbers,\n        the location and nature of sources,  (d)  the position and size of any DFT cells in which\n      frequency-domain fields are to be computed.    Time-domain fields during timestepping.  An animation or movie showing the time-domain fields evolving\n      throughout the timestepping. For one thing, this tells you instantly when you have e.g. oriented your\n      source backwards or otherwise misconfigured something obvious---you sit and watch all of \n      your \"input\" power go flying right out of the cell to the left instead of proceeding rightward \n      into the center like you intended---whereas the  frequency -domain plots produced even by \n      such totally misbegotten simulations can be pretty effective at obscuring even obvious\n      culprits.\n      Also, after all, the ability to observe essentially time-domain phenomena is one of the\n      key reasons to use an FDTD tool in the first place; many frequency-domain problems\n      can be solved much more efficiently by frequency-domain solvers than by something like\n       meep , but they don't produce nice movies showing e.g.\n      reflection and diffraction of wave packets from interfaces. So it seems particularly\n      appropriate for a time-domain-solver like  meep  to offer\n      built-in functionality for animating time-domain field evolutions.    _  Frequency-domain fields after timestepping.  A static image showing the amplitudes of frequency-domain fields\n    in regions of DFT cells, with the spatial distributiono of Poynting flux plotted for DFT flux cells.    A central goal of this module is to provide reliable, easy-to-use routines for\n     each of these purposes.   They should offer a hierarchy of customizability options  for users at different\n   places on the willingness-to-suffer-for-their-art spectrum.\n   Of course, the goals outlined above---routines that are  easy to use  and  just work ---suggest\n   an implementation strategy in which the tools make all the artistic decisions for you; the easiest\n   calling convention to remember is the one with no parameters. However, one of the nice things\n   about the  matplotlib  backend is how very  extremely \n   customizable it is, and it shouldn't be hard to pass at least some of those options\n   on to users of  meep.adjoint.Visualization.  \n   In view of these considerations, the goal of the routines is to offer\n   a three-tiered hierarchy of customizability levels.   a. * The zero-effort calling model for lazy forgetful slackers *  For users who can't be bothered to memorize or look up library function\n   prototypes---or who just want quick and dirty visualization at the\n   prototyping stage with the option to clean up later---it should be \n   possible to call the visualization routines on just the  simulation  \n   entity alone  with no configuration arguments whatsoever, \n   with the module making reasonable choices to produce helpful graphics \n   in a standardized format.  b. **Minimal-effort calling model for the slightly more motivated**\nFor users who fall basically into the previous bucket but are\nmotivated to change one or another option that otherwise\nobstructs the visualization (like, label font size too large),\nthere should be an easy way to configure global settings once,\nafter which the user can proceed lazily to call all visualization\nroutines with no customization arguments.\n\nc. **Full-customization calling model for diligent nitpickers:**\nFinally, for users who *do* want to invest time and effort to \nconfigure plotting options to their liking, the visualization\nmodule should provide copious customization options to allow\nas much as possible of the visualization to be customized.", 
            "title": "Motivation and philosophy"
        }, 
        {
            "location": "/AdjointSolver/Visualization/#2-easy-visualization-of-simulation-geometries-before-timestepping-visualize_sim", 
            "text": "As described above, the first visualization task we consider\nis that of double-checking the various geometric inputs\nsupplied to  pymeep  when creating a  simulation :\nthe computational cell and material geometry, the absorbing boundaries, the exciting sources, \nand any DFT cells for which we requested tabulation of frequency-domain fields. Also described\nabove was the imperative that, to ensure a maximally memorable calling convention,\n the visualization routine be callable on *just the  simulation  class itself with no\nother parameters required. These objectives are satisfied by the visualize_sim routine in meep.adjoint.Visualization ,\nwhose calling convention is precision-engineered to be as painless as possible: after\ncreating a  span class=SC pymeep /sc simulation /sc \nthrough by a call like #!py3 sim=mp.simulation(geometry=...)`, \nyou can simply say     visualize_sim ( sim )   and voil\u00e0! A new plot window sprouts open to reveal your simulation\nin all its glory, looking something like this:   ![   as one example, here's what  visualize_sim \nproduces for the  Hole Cloak \nexample discussed in the adjoint-solver documentation:\n```  True to form, the visualization function for this scenario  (although there are many  optional  parameters \nde  All of this information is presented in graphical\nform", 
            "title": "2. Easy visualization of simulation geometries before timestepping: visualize_sim"
        }, 
        {
            "location": "/AdjointSolver/Visualization/#during-timestepping-real-time-visualization-of-time-domain-field-evolution", 
            "text": "spl\nTo support this,  meep.adjoint.Visualization  defines a new step function \nthat you can pass to the\n[run function][RunFunctions] you use\nto drive timestepping.", 
            "title": "During timestepping: Real-time visualization of time-domain field evolution"
        }, 
        {
            "location": "/AdjointSolver/Visualization/#after-timestepping-visualizing-frequency-domain-poynting-fluxes-and-energy-densities", 
            "text": "", 
            "title": "After timestepping: Visualizing frequency-domain Poynting fluxes and energy densities"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/", 
            "text": "$$\n   \\newcommand{\\vb}{\\mathbf}\n   \\newcommand{\\wt}{\\widetilde}\n   \\newcommand{\\mc}{\\mathcal}\n   \\newcommand{\\bmc}[1]{\\boldsymbol{\\mathcal{#1}}}\n   \\newcommand{\\sup}[1]{^{\\text{#1}}}\n   \\newcommand{\\sups}[1]{^{\\text{#1}}}\n   \\newcommand{\\sub}[1]{_{\\text{#1}}}\n   \\newcommand{\\subs}[1]{_{\\text{#1}}}\n   \\newcommand{\\pard}[2]{\\frac{\\partial #1}{\\partial #2}}\n   \\newcommand{\\VMV}[3]{ \\Big\\langle #1 \\Big| #2 \\Big| #3 \\Big\\rangle}\n$$\n\n\n\n.superfences-tabs {\n  display: flex;\n  position: relative;\n  flex-wrap: wrap;\n}\n\n.superfences-tabs .highlight {\n  background: #ddd;\n}\n\n.superfences-tabs .superfences-content {\n  display: none;\n  order: 99;\n  width: 100%;\n}\n\n.superfences-tabs label {\n  width: auto;\n  margin: 0 0.5em;\n  padding: 0.25em;\n  font-size: 120%;\n  cursor: pointer;\n}\n\n.superfences-tabs input {\n  position: absolute;\n  opacity: 0;\n}\n\n.superfences-tabs input:nth-child(n+1) {\n  color: #333333;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label {\n    color: #FF5252;\n}\n\n.superfences-tabs input:nth-child(n+1):checked + label + .superfences-content {\n    display: block;\n}\n\n\n\n\nAdjoint-based optimization in \nmeep\n: Implementation Notes\n\n\nThese notes are intended as something of a companion to the\n\nuser's manual and tutorial documentation for adjoint-based\noptimization in \nmeep\n; \nwhereas the goal of those pages is to document the user interface\nand explain how to \nuse\n the solver for practical problems,\nour focus here will be what's going on beneath the hood---how\nthe solver actually \nworks.\n\n\nActually, as will be clear to anyone who has ever reviewed the\nfundamentals of\n\nadjoint sensitivity analysis\n,\nthe theoretical basis of the method and the derivation of its key\nformulas are almost trivially straightforward, with the only\npotential source of difficulty being how to massage the mechanics\nof the procedure into a \nmeep\n-friendly form.\n\n\nToy problem\n\n\nUltimately we will want to use adjoint methods to differentiate\ncomplex objective functions---involving quantities such as\nPoynting fluxes and mode-expansion coefficients---with respect\nto various different types of parameters describing material geometries.\nHowever, before tackling the problem in that full generality,\nit's useful to build up to it by starting with a simple toy problem\nand adding complications one at a time. Thus we consider a\nsimple waveguide geometry, excited by a point source at\n\n\\vb{x}\\sup{src}\n\\vb{x}\\sup{src}\n, and define our objective function to be\nsimply the frequency-domain electric-field amplitude at\na point \n\\vb{x}\\sup{obj}\n\\vb{x}\\sup{obj}\n; we will compute the derivative\nof this objective function with respect to the permittivity\n\n\\epsilon\\sup{des}\n\\epsilon\\sup{des}\n\nin a small \"design region\" \n\\mc{V}\\sup{des}\n\\mc{V}\\sup{des}\n\ncentered at a third point \n\\vb{x}\\sup{des}\n\\vb{x}\\sup{des}\n.\n\n\n\n\nPermittivity derivative by finite-differencing\n\n\nAn obvious brute-force way to get at this is simply\nto do two \nmeep\n calculations, with \n\\epsilon\\sup{des}\n\\epsilon\\sup{des}\n\naugmented by a small finite amount \n\\Delta\\epsilon\n\\Delta\\epsilon\n on the\nsecond run, then compute the difference between the frequency-domain\nelectric fields at \n\\vb{x}\\sup{obj}\n\\vb{x}\\sup{obj}\n and divide\nby \n\\Delta\\epsilon\n\\Delta\\epsilon\n to estimate the derivative.\nHere are plots of the unperturbed field and the field perturbation\n(difference between perturbed and unperturbed field):\n\n\n\n\n\\wt{E_{z0}}(\\omega_0, \\vb{x})\n\\wt{E_{z0}}(\\omega_0, \\vb{x})\n (unperturbed):\n\n\n\n\n\n\n\n\n\\Delta {\\wt E_z}(\\omega_0, \\vb{x})\n\\Delta {\\wt E_z}(\\omega_0, \\vb{x})\n (perturbed-unperturbed):\n\n\n\n\n\n(Here and below we use the tilde sign (\n\\sim\n\\sim\n) to indicate frequency-domain\nfields and sources.)\n\n\nPermittivity derivative from effective sources\n\n\nOne way to think about the effect of a localized permittivity\nbump goes like this: Increasing the permittivity in some localized\nregion of a material body corresponds to increasing the\npolarizability in that region---that is, the ease with which\npositive and negative charges in the material, ordinarily bound\nso tightly together that they neutralize each other as sources,\ncan be induced by applied electric fields to separate (\"polarize\"),\nwhereupon they cease to cancel each other and act as effective\nsources contributing to electromagnetic fields.\nOf course, if there were no electric field in the material,\nthen we could increase its polarizability as much as we pleased\nwithout producing any sources---zero times a bigger\ncoefficient being still zero---but here there \nis\n a nonzero\nelectric field throughout our geometry, due to the point source\nin the unperturbed problem, which means that the effect of bumping the\npermittivity of the design region may be approximated by\nadding new \nsources\n in that region, with strength\nproportional to \n\\Delta\\epsilon\n\\Delta\\epsilon\n and to the unperturbed electric field.\nMore specifically, in a frequency-domain problem involving time-harmonic\nfields and sources with angular frequency \n\\omega\n\\omega\n (time dependence\n\n\\propto e^{-i\\omega t}\n\\propto e^{-i\\omega t}\n), the following perturbations are\nequivalent:\n$$\n\\begin{array}{ccc}\n \\left(\\begin{array}{c}\n \\text{a permittivity shift of } \\Delta\\epsilon \\\n \\text{over a small region } \\mc{V} \\text{ in which} \\\n \\text{the electric field is } \\wt{\\vb{E}}\n \\end{array}\\right)\n \n\\Longleftrightarrow \n\n  \\left(\\begin{array}{c}\n   \\text{a localized electric current } \\\n   \\text{flowing in }\\mc{V} \\text{ with amplitude } \\\n   \\Delta\\wt{\\vb J}=-i\\omega\\Delta\\epsilon \\wt{\\vb{E}}\n  \\end{array}\\right)\n\\end{array}\n$$\n\n\n \n\n\nSuperposing this effective source with the original point source\nat \n\\vb{x}\\sup{src}\n\\vb{x}\\sup{src}\n yields a source configuration that,\nacting on the \nunperturbed\n geometry, produces the same fields\nas the point source alone acting on the \nperturbed\n geometry.\n\n\nAlternatively, by exploiting the linearity of Maxwell's equations\n(and assuming we have linear media!) we could just as easily\nremove the original point source and compute the fields of\n\n\\wt{\\Delta \\vb{J}}\n\\wt{\\Delta \\vb{J}}\n \nalone\n, which, upon dividing through by\n\n\\Delta\\epsilon\n\\Delta\\epsilon\n, give just the derivatives of field components\nwith respect to \n\\epsilon\n\\epsilon\n. In other words,\n$$ \\pard{ \\wt{\\vb E} (\\vb x\\sup{obj}) }{\\epsilon\\sup{des}}\n   \\equiv\n   \\left(\\begin{array}{cc}\n   \\text{electric field at }\\vb{x}\\sup{obj} \\text{ due to }\\\n   \\text{current at }\\vb{x}\\sup{des}\\text{ with amplitude}\\\n   \\wt{\\Delta \\vb J}=-i\\omega\\wt{\\vb{E}}(\\vb{x}\\sup{obj})\n   \\end{array}\\right)\n   \\tag{1a}\n$$\nAnalogous reasoning yields a prescription for magnetic-field derivatives:\n$$ \\pard{\\wt{\\vb{H}}(\\vb x\\sup{obj})}{\\epsilon\\sup{des}}\n   \\equiv\n   \\left(\n   \\begin{array}{cc}\n   \\text{magnetic field at }\\vb{x}\\sup{obj} \\text{ due to }\\\n   \\text{current at }\\vb{x}\\sup{des}\\text{ with amplitude}\\\n   \\wt{\\Delta \\vb J}=-i\\omega\\wt{\\vb{E}}(\\vb{x}\\sup{obj})\n   \\end{array}\n   \\right)\n   \\tag{1b}\n$$\n\n\nDigression: Configuring time-domain sources for desired frequency-domain fields in \nmeep\n\n\nIn frequency-domain electromagnetism we usually consider \na time-harmonic source distribution of the form\n$$\n   \\vb{J}\\sup{monochromatic}(t,\\vb{x})\\equiv \n   \\wt{\\vb{J}}(\\vb x)e^{-i\\omega t}\n$$\nand we ask for the time-harmonic electric field distribution\nradiated by this distribution:\n$$\n  \\vb{E}\\sup{monochromatic}(t,\\vb{x})\\equiv \n  \\wt{\\vb{E}}(\\vb x)e^{-i\\omega t}\n$$\nwhere \n\\sim\n\\sim\n indicates frequency-domain amplitudes.\nA typical frequency-domain solver might input\n\n\\wt{\\vb J}(\\vb x)\n\\wt{\\vb J}(\\vb x)\n and output\n\n\\wt{\\vb E}(\\vb x)\n\\wt{\\vb E}(\\vb x)\n:\n$$ \\wt{\\vb J}(\\vb x)\n   \\quad \\Longrightarrow \\quad\n   \\begin{array}{|c|}\\hline\\\n   \\text{    frequency-domain solver    }\\\n   \\\\hline\\end{array}\n   \\quad \\Longrightarrow \\quad\n   \\wt{\\vb E}(\\vb x)\n$$\n\n\nOn the other hand, when using \nmeep\n to compute\nthe fields produced by a given spatial source distribution,\nwe typically construct a time-domain source of the form\n\n\\vb{J}\\sup{meep}(t,\\vb{x})=G(t)\\wt{\\vb{J}}(\\vb x)\n\\vb{J}\\sup{meep}(t,\\vb{x})=G(t)\\wt{\\vb{J}}(\\vb x)\n<span><span class=\"MathJax_Preview\">\\vb{J}\\sup{meep}(t,\\vb{x})=G(t)\\wt{\\vb{J}}(\\vb x)</span><script type=\"math/tex\">\\vb{J}\\sup{meep}(t,\\vb{x})=G(t)\\wt{\\vb{J}}(\\vb x)\n\nwhere \nG(t)\nG(t)\n is a Gaussian temporal envelope.\nMore specifically, for \nmeep\n's \nGaussianSrc\n with\ncenter frequency \n\\omega_0=2\\pi f_0\n\\omega_0=2\\pi f_0\n,\nfrequency width \n\\Delta \\omega =2\\pi \\Delta f\n\\Delta \\omega =2\\pi \\Delta f\n, and\npeak time \nt_0\nt_0\n, we have\n$$ G(t) = e^{-i\\omega_0(t-t_0) - \\frac{1}{2}[\\Delta f(t-t_0)]^2}.$$\nThe Fourier transform of this is\n$$\n   \\wt G(\\omega) \\equiv \\frac{1}{\\sqrt{2\\pi}}\n   \\int e^{i\\omega t}G(t)\\,dt =\n   \\frac{1}{\\Delta f}\n   e^{i\\omega t_0 -\\frac{(\\omega-\\omega_0)^2}{2\\Delta f^2}}.\n$$\nThe \nmeep\n version of the above\ninput/output diagram looks like\n$$ G(t)\\wt{\\vb J}(\\vb x)\n   \\quad \\Longrightarrow \\quad\n   \\begin{array}{|c|}\\hline\\\n   \\text{ MEEP }\\\n   \\text{    (timestepping + DFT)    } \\\n   \\\\hline\\end{array}\n   \\quad \\Longrightarrow \\quad\n   \\wt{G}(\\omega)\\wt{\\vb E}(\\vb x)\n$$\n\n\nThe upshot is that the frequency-domain fields obtained from a\n\nmeep\n run with a Gaussian source\ncome out multiplied by a factor of \n\\wt{G}(\\omega)\n\\wt{G}(\\omega)\n that should\nbe divided out to yield the desired frequency-domain quantities.\n\n\nInvoking reciprocity\n\n\nIt is convenient to describe the process described above\nin the language of frequency-domain Green's functions, which\nexpress the fields radiated by monochromatic source distributions\nas spatial convolutions:\n$$ \\wt{E_i}(\\omega, \\vb{x}\\sup{dest}) =\n   \\int\n   \\mc{G}\\sup{EE}\n{ij}(\\omega, \\vb{x}\\sup{dest}, \\vb{x}\\sup{src}) \n   \\wt{J_j}(\\omega, \\vb{x}\\sup{src})\n  \\,d\\vb{x}\\sup{src}\n$$\nwith \n\\bmc{G}\\sup{EE}\n\\bmc{G}\\sup{EE}\n the\nelectric-electric dyadic Green's function of the material geometry\n(giving the electric field produced by a unit-strength electric \ncurrent).\nIn this language, the effective-source representation\nof the permittivity derivative reads\n$$ \\pard{\\wt{E}_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n   =\n   \\int \\mc{G}\\sup{EE}\n(\\vb{x}\\sup{obj}, \\vb{x}\\sup{des})\n   \\left[-i\\omega \\wt{E}\nj(\\vb{x}\\sup{des})\\right]\n   \\,d\\vb{x}\\sup{des}\n$$\nIt is convenient to think of the RHS here as a double convolution\nof two vector-valued functions with the \n\\bmc{G}\\sup{EE}\n\\bmc{G}\\sup{EE}\n kernel:\n$$ \\pard{\\wt{E}_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n   =\n    \\left[ \\vphantom{\\wt{\\vb E}\\sup{des}}\n           \\,\\, \\boldsymbol{\\delta}_i\\sup{obj}\\,\\,\n   \\right]\n   \\star \\bmc{G}\\sup{EE} \\star\n   \\left[-i\\omega \\wt{\\vb E}\\sup{des}\\right]\n$$\nor\n$$ \\pard{\\wt E_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n   =-i\\omega\\VMV{ \\boldsymbol{\\delta}_i\\sup{obj} }\n                { \\bmc G\\sup{EE}                 }\n                { \\wt{\\vb E}\\sup{des}            }\n$$\nwhere \n\\star\n\\star\n denotes convolution,\n\n\\boldsymbol{\\delta}_i\\sup{obj}\n\\boldsymbol{\\delta}_i\\sup{obj}\n is short for\n\n\\delta_{ij} \\delta(\\vb{x}-\\vb{x}\\sup{obj}),\n\\delta_{ij} \\delta(\\vb{x}-\\vb{x}\\sup{obj}),\n\nand the bra-ket notation describes a machine that inputs two\nvector-valued functions \n\\vb{f},\\vb{g}\n\\vb{f},\\vb{g}\n and a kernel \n\\mc{K}\n\\mc{K}\n\nand outputs a scalar quantity:\n$$ \\VMV{\\vb f}{\\bmc K}{\\vb g}\n   \\equiv \\sum\n \\iint f_i(\\vb{x})\n                          \\mc{K}_{ij}(\\vb{x},\\vb{x}^\\prime)\n                          g_j(\\vb{x}^\\prime)\n                          \\,d\\vb{x} \\,d\\vb{x}^\\prime\n$$\n(Note that this is not a Hermitian inner product, i.e. the first\nfactor is not conjugated.) \n\n\nFor the magnetic-field derivative we have similarly\n$$ \\pard{\\wt{H}_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n   =-i\\omega\\VMV{ \\boldsymbol{\\delta}_i\\sup{obj} }\n                { \\boldsymbol{\\mc G}\\sup{ME}   }\n                { \\wt{\\vb E}\\sup{des}          }\n$$\nwhere \n\\bmc{G}\\sup{ME}\n\\bmc{G}\\sup{ME}\n is the magnetic-electric\nGreen's function, giving the magnetic field produced \nby an electric current.\n\n\nComputationally, inner products like\n\n\\VMV{\\vb f}{\\bmc G\\sup{EE}}{\\vb g}\n\\VMV{\\vb f}{\\bmc G\\sup{EE}}{\\vb g}\n \nfor arbitrary functions \n\\vb{f}(\\vb x), \\vb{g}(\\vb x)\n\\vb{f}(\\vb x), \\vb{g}(\\vb x)\n\nmay be evaluated in \nmeep\n\nas follows:\n\n\n\n\n\n\nCreate an electric current source with\n   spatially-varying amplitude \n\\vb{g}(\\vb x)\n\\vb{g}(\\vb x)\n\n   and Gaussian temporal envelope \nG(t)\nG(t)\n.\n\n\n\n\n\n\nTimestep and DFT to compute the frequency-domain electric field\n   \n\\wt{\\vb E}(\\omega; \\vb{x})\n\\wt{\\vb E}(\\omega; \\vb{x})\n produced by this source.\n\n\n\n\n\n\nCompute the inner product\n   \n[\\wt{G}(\\omega)]^{-1}\n    \\int \\vb{f}\\cdot \\wt{\\vb E}\\,dV.\n[\\wt{G}(\\omega)]^{-1}\n    \\int \\vb{f}\\cdot \\wt{\\vb E}\\,dV.\n\n   (The normalization prefactor was discussed above.)\n\n\n\n\n\n\nThe virtue of writing things this way is that it allows the physical\nproperty of reciprocity to be expressed as the mathematical property\nthat the aforementioned inner-product machine is insensitive to the\norder of its arguments, i.e. we can flip the \n\\vb f\n\\vb f\n and \n\\vb g\n\\vb g\n \ninputs and still get the same scalar output:\n$$ \\VMV{\\vb f}{\\bmc K}{\\vb g} = \\VMV{\\vb g}{\\bmc K}{\\vb f}\n   \\quad\\text{ for }\\quad \\bmc K= \\bmc{G}\\sup{EE}, \\bmc{G}\\sup{ME}.\n$$\n\n\nApplying reciprocity to the above expressions for field derivatives yields\n\\begin{align\n}\n\\pard{\\wt E_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n \n=-i\\omega\\VMV{ \\wt{\\vb E }\\sup{des}         }\n               { \\bmc{G}\\sup{EE}              }\n               { \\boldsymbol{\\delta}_i\\sup{obj} }\n \\tag{2}\n\\[5pt]\n\\pard{\\wt H_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n \n=-i\\omega\\VMV{ \\wt{\\vb E }\\sup{des}         }\n               { \\bmc{G}\\sup{ME}              }\n               { \\boldsymbol{\\delta}_i\\sup{obj} }\n \\tag{3a}\n\\\n \\hphantom{\\pard{\\wt H_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}}\n  \n=+i\\omega\\VMV{ \\wt{\\vb E}\\sup{des}          }\n                { \\bmc{G}\\sup{EM}              }\n                { \\boldsymbol{\\delta}_i\\sup{obj} }\n \\tag{3b}\n\\end{align\n}\nwhere in going to the last line we invoked the identity\n\n\\bmc{G}\\sup{EM}=-\\bmc{G}\\sup{ME}.\n\\bmc{G}\\sup{EM}=-\\bmc{G}\\sup{ME}.\n\n\nNote that equations (3a) and (3b), notwithstanding their nearly\nidentical appearance, describe two rather different\n\nmeep\n calculations: In the former case\nwe place an electric source at \n\\vb x\\sup{obj}\n\\vb x\\sup{obj}\n and timestep to\ncompute the resulting magnetic field, while in the latter\ncase we place a magnetic source and timestep\nto compute the resulting electric field. (In both cases,\nupon computing the field in question we proceed to compute its\noverlap with the unperturbed \n\\vb E\n\\vb E\n field in the design region.)\n\n\nDifferentiating more complicated functions of field components\n\n\nThus far we have only considered derivatives of individual\nfield components, and then only at a single point \n\\vb{x}\\sup{obj}\n\\vb{x}\\sup{obj}\n;\nmore generally, we will want to differentiate functions of\nmultiple field components over a subregion of the grid,\nwhich we will call the \nobjective region\n \n\\mc{V}\\sup{obj}\n\\mc{V}\\sup{obj}\n.\n\n\nE\n-field energy in region\n\n\nAs one example, the electric field energy in the objective\nregion is defined by an integral over that region, which \nmeep\n\napproximate by a weighted sum over grid points:\n$$ \\mc{E}=\n   \\frac{1}{2}\\int_{\\mc{V}\\sup{obj}} \\epsilon |\\wt{\\vb E}|^2 \\,d\\mc{V}\n   \\approx\n   \\frac{1}{2}\\sum_{i,\\vb{n}\\in\\mc{V}\\sup{obj}} w_{\\vb{n}}\n   \\epsilon_\\vb {n} \\wt E_{i\\vb n}^* \\wt E_{i\\vb n}\n$$\nHere the sum is over all field components \ni=\\{x,y,z\\}\ni=\\{x,y,z\\}\n and\nall grid points \n\\vb{n}\n\\vb{n}\n lying in \n\\mc{V}\\sup{obj}\n\\mc{V}\\sup{obj}\n,\nand \nw_{\\vb{n}}\nw_{\\vb{n}}\n is a cubature weight associated with point \n\\vb{n}\n\\vb{n}\n\n(as returned by \nget_dft_array_metadata\n).\nDifferentiating, we have\n\\begin{align\n}\n \\pard{\\mc E}{\\epsilon\\sup{des}}\n \n=\\text{Re }\\sum_{i\\vb{n}\\in\\mc V\\sup{obj}} w_{\\vb n}\\epsilon_{\\vb n}\n   \\wt{E}^\n{i\\vb n} \\pard{\\wt{E}\n} {\\epsilon\\sup{des}}\n\\\n\n\\hspace{-1.5in}\\text{Insert equation (1a):}\n\\\n \n=\\text{Re }\\left{ -i\\omega \\VMV{\\epsilon \\wt{\\vb E}\\sup{obj\n}}\n                                   {{\\bmc G}\\sup{EE}}\n                                   {\\wt{\\vb E}\\sup{des}}\n              \\right}\n\\\n\n\\hspace{-1.5in}\\text{Invoke reciprocity:}\n\\\n \n=\\text{Re }\\left{ -i\\omega \\VMV{\\wt{\\vb E}\\sup{des}}\n                                  {{\\bmc G}\\sup{EE}}\n                                  {\\epsilon \\wt{\\vb E}\\sup{obj\n}}\n              \\right}\n\\end{align*}\n\n\nPoynting flux\n\n\nA case that arises frequently is that in which the objective region\nis a cross-sectional surface \n\\mc S\\sup{obj}\n\\mc S\\sup{obj}\n cutting normally through a\nwaveguide or similar structure and the objective function is the \nnormal Poynting flux through \n\\mc S\n\\mc S\n.\nFor example, the \nx\nx\n-directed Poynting flux is given by\n$$\n S_x\n=\n\\frac{1}{2}\\text{Re }\\left{ \\int_{\\mc S\\sup{obj}} \\Big(E^\ny H_z + \\cdots\\Big) \\, d\\mathbf{x} \\right}\n\\approx \\frac{1}{2}\\text{Re }\\sum\n} w_{\\vb n}\n \\Big(E^\n{y\\vb n} H\n + \\cdots\\Big)\n$$\nwhere \n\\cdots\n\\cdots\n refers to three other terms of the form \n\\pm E^*_i H_j\n\\pm E^*_i H_j\n.\nDifferentiating and rearranging slightly, we have\n\\begin{align\n}\n \\pard{S_x}{\\epsilon\\sup{des}}\n \n=\\text{Re }\\sum_{\\vb n\\in \\mc S\\sup{obj}} w\n   \\left{ \\wt{E}^\n_{y} \\pard{\\wt{H}_z}{\\epsilon\\sup{des}}\n          +\\wt{H}^\n{z} \\pard{\\wt{E}_y}{\\epsilon\\sup{des}}\n         +\\cdots\n   \\right}\n\\[5pt]\n\n\\hspace{-0.5in}\\text{Use (1a) and (1b):}\n\\[5pt]\n \n=\\text{Re }\\left{ -i\\omega \\VMV{\\wt{\\vb E}\n\\sup{obj\n}}\n                                  {\\bmc G\\sup{ME}}\n                                  {\\wt{\\vb E}\\sup{des}}\n                     -i\\omega \\VMV{\\wt{\\vb H}_z\\sup{obj\n}}\n                                  {\\bmc G\\sup{EE}}\n                                  {\\wt{\\vb E}\\sup{des}}\n                     +\\cdots\n            \\right} \n\\[5pt]\n\n\\hspace{-0.5in}\\text{Use reciprocity:}\n\\[5pt]\n\n=\\text{Re }\\left{ -i\\omega  \\VMV{\\wt{\\vb E}\\sup{des}}\n                                  {\\bmc G\\sup{ME}}\n                                  {\\wt{\\vb E}_y\\sup{obj\n}}\n                    -i\\omega \\VMV{\\wt{\\vb E}\\sup{des}}\n                                 {\\bmc G\\sup{EE}}\n                                 {\\wt{\\vb H}_z\\sup{obj\n}}\n                    +\\cdots\n              \\right}\n\\end{align\n}\n\n\nMode coefficient\n\n\n$$ \\alpha_m^\\pm = C_1 \\pm C_2 $$\n\\begin{align\n}\n C_1 \n=\\frac{1}{\\mathcal{N}}\n   \\int_{\\mc S\\sup{obj}} \\Big(e^\n_y H_z - e^\nz H_y\\Big)d\\mathbf{x}\\\n C_2 \n=\n   \\frac{1}{\\mathcal{N}}\\int\n} \\Big(h^\n_z E_y - h^\n_y E_z\\Big)d\\mathbf{x}\\\n\\end{align\n}", 
            "title": "Implementation Notes"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#adjoint-based-optimization-in-meep-implementation-notes", 
            "text": "These notes are intended as something of a companion to the user's manual and tutorial documentation for adjoint-based\noptimization in  meep ; \nwhereas the goal of those pages is to document the user interface\nand explain how to  use  the solver for practical problems,\nour focus here will be what's going on beneath the hood---how\nthe solver actually  works.  Actually, as will be clear to anyone who has ever reviewed the\nfundamentals of adjoint sensitivity analysis ,\nthe theoretical basis of the method and the derivation of its key\nformulas are almost trivially straightforward, with the only\npotential source of difficulty being how to massage the mechanics\nof the procedure into a  meep -friendly form.", 
            "title": "Adjoint-based optimization in meep: Implementation Notes"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#toy-problem", 
            "text": "Ultimately we will want to use adjoint methods to differentiate\ncomplex objective functions---involving quantities such as\nPoynting fluxes and mode-expansion coefficients---with respect\nto various different types of parameters describing material geometries.\nHowever, before tackling the problem in that full generality,\nit's useful to build up to it by starting with a simple toy problem\nand adding complications one at a time. Thus we consider a\nsimple waveguide geometry, excited by a point source at \\vb{x}\\sup{src} \\vb{x}\\sup{src} , and define our objective function to be\nsimply the frequency-domain electric-field amplitude at\na point  \\vb{x}\\sup{obj} \\vb{x}\\sup{obj} ; we will compute the derivative\nof this objective function with respect to the permittivity \\epsilon\\sup{des} \\epsilon\\sup{des} \nin a small \"design region\"  \\mc{V}\\sup{des} \\mc{V}\\sup{des} \ncentered at a third point  \\vb{x}\\sup{des} \\vb{x}\\sup{des} .", 
            "title": "Toy problem"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#permittivity-derivative-by-finite-differencing", 
            "text": "An obvious brute-force way to get at this is simply\nto do two  meep  calculations, with  \\epsilon\\sup{des} \\epsilon\\sup{des} \naugmented by a small finite amount  \\Delta\\epsilon \\Delta\\epsilon  on the\nsecond run, then compute the difference between the frequency-domain\nelectric fields at  \\vb{x}\\sup{obj} \\vb{x}\\sup{obj}  and divide\nby  \\Delta\\epsilon \\Delta\\epsilon  to estimate the derivative.\nHere are plots of the unperturbed field and the field perturbation\n(difference between perturbed and unperturbed field):   \\wt{E_{z0}}(\\omega_0, \\vb{x}) \\wt{E_{z0}}(\\omega_0, \\vb{x})  (unperturbed):     \\Delta {\\wt E_z}(\\omega_0, \\vb{x}) \\Delta {\\wt E_z}(\\omega_0, \\vb{x})  (perturbed-unperturbed):   (Here and below we use the tilde sign ( \\sim \\sim ) to indicate frequency-domain\nfields and sources.)", 
            "title": "Permittivity derivative by finite-differencing"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#permittivity-derivative-from-effective-sources", 
            "text": "One way to think about the effect of a localized permittivity\nbump goes like this: Increasing the permittivity in some localized\nregion of a material body corresponds to increasing the\npolarizability in that region---that is, the ease with which\npositive and negative charges in the material, ordinarily bound\nso tightly together that they neutralize each other as sources,\ncan be induced by applied electric fields to separate (\"polarize\"),\nwhereupon they cease to cancel each other and act as effective\nsources contributing to electromagnetic fields.\nOf course, if there were no electric field in the material,\nthen we could increase its polarizability as much as we pleased\nwithout producing any sources---zero times a bigger\ncoefficient being still zero---but here there  is  a nonzero\nelectric field throughout our geometry, due to the point source\nin the unperturbed problem, which means that the effect of bumping the\npermittivity of the design region may be approximated by\nadding new  sources  in that region, with strength\nproportional to  \\Delta\\epsilon \\Delta\\epsilon  and to the unperturbed electric field.\nMore specifically, in a frequency-domain problem involving time-harmonic\nfields and sources with angular frequency  \\omega \\omega  (time dependence \\propto e^{-i\\omega t} \\propto e^{-i\\omega t} ), the following perturbations are\nequivalent:\n$$\n\\begin{array}{ccc}\n \\left(\\begin{array}{c}\n \\text{a permittivity shift of } \\Delta\\epsilon \\\n \\text{over a small region } \\mc{V} \\text{ in which} \\\n \\text{the electric field is } \\wt{\\vb{E}}\n \\end{array}\\right)\n  \\Longleftrightarrow  \n  \\left(\\begin{array}{c}\n   \\text{a localized electric current } \\\n   \\text{flowing in }\\mc{V} \\text{ with amplitude } \\\n   \\Delta\\wt{\\vb J}=-i\\omega\\Delta\\epsilon \\wt{\\vb{E}}\n  \\end{array}\\right)\n\\end{array}\n$$     Superposing this effective source with the original point source\nat  \\vb{x}\\sup{src} \\vb{x}\\sup{src}  yields a source configuration that,\nacting on the  unperturbed  geometry, produces the same fields\nas the point source alone acting on the  perturbed  geometry.  Alternatively, by exploiting the linearity of Maxwell's equations\n(and assuming we have linear media!) we could just as easily\nremove the original point source and compute the fields of \\wt{\\Delta \\vb{J}} \\wt{\\Delta \\vb{J}}   alone , which, upon dividing through by \\Delta\\epsilon \\Delta\\epsilon , give just the derivatives of field components\nwith respect to  \\epsilon \\epsilon . In other words,\n$$ \\pard{ \\wt{\\vb E} (\\vb x\\sup{obj}) }{\\epsilon\\sup{des}}\n   \\equiv\n   \\left(\\begin{array}{cc}\n   \\text{electric field at }\\vb{x}\\sup{obj} \\text{ due to }\\\n   \\text{current at }\\vb{x}\\sup{des}\\text{ with amplitude}\\\n   \\wt{\\Delta \\vb J}=-i\\omega\\wt{\\vb{E}}(\\vb{x}\\sup{obj})\n   \\end{array}\\right)\n   \\tag{1a}\n$$\nAnalogous reasoning yields a prescription for magnetic-field derivatives:\n$$ \\pard{\\wt{\\vb{H}}(\\vb x\\sup{obj})}{\\epsilon\\sup{des}}\n   \\equiv\n   \\left(\n   \\begin{array}{cc}\n   \\text{magnetic field at }\\vb{x}\\sup{obj} \\text{ due to }\\\n   \\text{current at }\\vb{x}\\sup{des}\\text{ with amplitude}\\\n   \\wt{\\Delta \\vb J}=-i\\omega\\wt{\\vb{E}}(\\vb{x}\\sup{obj})\n   \\end{array}\n   \\right)\n   \\tag{1b}\n$$", 
            "title": "Permittivity derivative from effective sources"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#digression-configuring-time-domain-sources-for-desired-frequency-domain-fields-in-meep", 
            "text": "In frequency-domain electromagnetism we usually consider \na time-harmonic source distribution of the form\n$$\n   \\vb{J}\\sup{monochromatic}(t,\\vb{x})\\equiv \n   \\wt{\\vb{J}}(\\vb x)e^{-i\\omega t}\n$$\nand we ask for the time-harmonic electric field distribution\nradiated by this distribution:\n$$\n  \\vb{E}\\sup{monochromatic}(t,\\vb{x})\\equiv \n  \\wt{\\vb{E}}(\\vb x)e^{-i\\omega t}\n$$\nwhere  \\sim \\sim  indicates frequency-domain amplitudes.\nA typical frequency-domain solver might input \\wt{\\vb J}(\\vb x) \\wt{\\vb J}(\\vb x)  and output \\wt{\\vb E}(\\vb x) \\wt{\\vb E}(\\vb x) :\n$$ \\wt{\\vb J}(\\vb x)\n   \\quad \\Longrightarrow \\quad\n   \\begin{array}{|c|}\\hline\\\n   \\text{    frequency-domain solver    }\\\n   \\\\hline\\end{array}\n   \\quad \\Longrightarrow \\quad\n   \\wt{\\vb E}(\\vb x)\n$$  On the other hand, when using  meep  to compute\nthe fields produced by a given spatial source distribution,\nwe typically construct a time-domain source of the form \\vb{J}\\sup{meep}(t,\\vb{x})=G(t)\\wt{\\vb{J}}(\\vb x) \\vb{J}\\sup{meep}(t,\\vb{x})=G(t)\\wt{\\vb{J}}(\\vb x) <span><span class=\"MathJax_Preview\">\\vb{J}\\sup{meep}(t,\\vb{x})=G(t)\\wt{\\vb{J}}(\\vb x)</span><script type=\"math/tex\">\\vb{J}\\sup{meep}(t,\\vb{x})=G(t)\\wt{\\vb{J}}(\\vb x) \nwhere  G(t) G(t)  is a Gaussian temporal envelope.\nMore specifically, for  meep 's  GaussianSrc  with\ncenter frequency  \\omega_0=2\\pi f_0 \\omega_0=2\\pi f_0 ,\nfrequency width  \\Delta \\omega =2\\pi \\Delta f \\Delta \\omega =2\\pi \\Delta f , and\npeak time  t_0 t_0 , we have\n$$ G(t) = e^{-i\\omega_0(t-t_0) - \\frac{1}{2}[\\Delta f(t-t_0)]^2}.$$\nThe Fourier transform of this is\n$$\n   \\wt G(\\omega) \\equiv \\frac{1}{\\sqrt{2\\pi}}\n   \\int e^{i\\omega t}G(t)\\,dt =\n   \\frac{1}{\\Delta f}\n   e^{i\\omega t_0 -\\frac{(\\omega-\\omega_0)^2}{2\\Delta f^2}}.\n$$\nThe  meep  version of the above\ninput/output diagram looks like\n$$ G(t)\\wt{\\vb J}(\\vb x)\n   \\quad \\Longrightarrow \\quad\n   \\begin{array}{|c|}\\hline\\\n   \\text{ MEEP }\\\n   \\text{    (timestepping + DFT)    } \\\n   \\\\hline\\end{array}\n   \\quad \\Longrightarrow \\quad\n   \\wt{G}(\\omega)\\wt{\\vb E}(\\vb x)\n$$  The upshot is that the frequency-domain fields obtained from a meep  run with a Gaussian source\ncome out multiplied by a factor of  \\wt{G}(\\omega) \\wt{G}(\\omega)  that should\nbe divided out to yield the desired frequency-domain quantities.", 
            "title": "Digression: Configuring time-domain sources for desired frequency-domain fields in meep"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#invoking-reciprocity", 
            "text": "It is convenient to describe the process described above\nin the language of frequency-domain Green's functions, which\nexpress the fields radiated by monochromatic source distributions\nas spatial convolutions:\n$$ \\wt{E_i}(\\omega, \\vb{x}\\sup{dest}) =\n   \\int\n   \\mc{G}\\sup{EE} {ij}(\\omega, \\vb{x}\\sup{dest}, \\vb{x}\\sup{src}) \n   \\wt{J_j}(\\omega, \\vb{x}\\sup{src})\n  \\,d\\vb{x}\\sup{src}\n$$\nwith  \\bmc{G}\\sup{EE} \\bmc{G}\\sup{EE}  the\nelectric-electric dyadic Green's function of the material geometry\n(giving the electric field produced by a unit-strength electric \ncurrent).\nIn this language, the effective-source representation\nof the permittivity derivative reads\n$$ \\pard{\\wt{E}_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n   =\n   \\int \\mc{G}\\sup{EE} (\\vb{x}\\sup{obj}, \\vb{x}\\sup{des})\n   \\left[-i\\omega \\wt{E} j(\\vb{x}\\sup{des})\\right]\n   \\,d\\vb{x}\\sup{des}\n$$\nIt is convenient to think of the RHS here as a double convolution\nof two vector-valued functions with the  \\bmc{G}\\sup{EE} \\bmc{G}\\sup{EE}  kernel:\n$$ \\pard{\\wt{E}_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n   =\n    \\left[ \\vphantom{\\wt{\\vb E}\\sup{des}}\n           \\,\\, \\boldsymbol{\\delta}_i\\sup{obj}\\,\\,\n   \\right]\n   \\star \\bmc{G}\\sup{EE} \\star\n   \\left[-i\\omega \\wt{\\vb E}\\sup{des}\\right]\n$$\nor\n$$ \\pard{\\wt E_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n   =-i\\omega\\VMV{ \\boldsymbol{\\delta}_i\\sup{obj} }\n                { \\bmc G\\sup{EE}                 }\n                { \\wt{\\vb E}\\sup{des}            }\n$$\nwhere  \\star \\star  denotes convolution, \\boldsymbol{\\delta}_i\\sup{obj} \\boldsymbol{\\delta}_i\\sup{obj}  is short for \\delta_{ij} \\delta(\\vb{x}-\\vb{x}\\sup{obj}), \\delta_{ij} \\delta(\\vb{x}-\\vb{x}\\sup{obj}), \nand the bra-ket notation describes a machine that inputs two\nvector-valued functions  \\vb{f},\\vb{g} \\vb{f},\\vb{g}  and a kernel  \\mc{K} \\mc{K} \nand outputs a scalar quantity:\n$$ \\VMV{\\vb f}{\\bmc K}{\\vb g}\n   \\equiv \\sum  \\iint f_i(\\vb{x})\n                          \\mc{K}_{ij}(\\vb{x},\\vb{x}^\\prime)\n                          g_j(\\vb{x}^\\prime)\n                          \\,d\\vb{x} \\,d\\vb{x}^\\prime\n$$\n(Note that this is not a Hermitian inner product, i.e. the first\nfactor is not conjugated.)   For the magnetic-field derivative we have similarly\n$$ \\pard{\\wt{H}_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n   =-i\\omega\\VMV{ \\boldsymbol{\\delta}_i\\sup{obj} }\n                { \\boldsymbol{\\mc G}\\sup{ME}   }\n                { \\wt{\\vb E}\\sup{des}          }\n$$\nwhere  \\bmc{G}\\sup{ME} \\bmc{G}\\sup{ME}  is the magnetic-electric\nGreen's function, giving the magnetic field produced \nby an electric current.  Computationally, inner products like \\VMV{\\vb f}{\\bmc G\\sup{EE}}{\\vb g} \\VMV{\\vb f}{\\bmc G\\sup{EE}}{\\vb g}  \nfor arbitrary functions  \\vb{f}(\\vb x), \\vb{g}(\\vb x) \\vb{f}(\\vb x), \\vb{g}(\\vb x) \nmay be evaluated in  meep \nas follows:    Create an electric current source with\n   spatially-varying amplitude  \\vb{g}(\\vb x) \\vb{g}(\\vb x) \n   and Gaussian temporal envelope  G(t) G(t) .    Timestep and DFT to compute the frequency-domain electric field\n    \\wt{\\vb E}(\\omega; \\vb{x}) \\wt{\\vb E}(\\omega; \\vb{x})  produced by this source.    Compute the inner product\n    [\\wt{G}(\\omega)]^{-1}\n    \\int \\vb{f}\\cdot \\wt{\\vb E}\\,dV. [\\wt{G}(\\omega)]^{-1}\n    \\int \\vb{f}\\cdot \\wt{\\vb E}\\,dV. \n   (The normalization prefactor was discussed above.)    The virtue of writing things this way is that it allows the physical\nproperty of reciprocity to be expressed as the mathematical property\nthat the aforementioned inner-product machine is insensitive to the\norder of its arguments, i.e. we can flip the  \\vb f \\vb f  and  \\vb g \\vb g  \ninputs and still get the same scalar output:\n$$ \\VMV{\\vb f}{\\bmc K}{\\vb g} = \\VMV{\\vb g}{\\bmc K}{\\vb f}\n   \\quad\\text{ for }\\quad \\bmc K= \\bmc{G}\\sup{EE}, \\bmc{G}\\sup{ME}.\n$$  Applying reciprocity to the above expressions for field derivatives yields\n\\begin{align }\n\\pard{\\wt E_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n  =-i\\omega\\VMV{ \\wt{\\vb E }\\sup{des}         }\n               { \\bmc{G}\\sup{EE}              }\n               { \\boldsymbol{\\delta}_i\\sup{obj} }\n \\tag{2}\n\\[5pt]\n\\pard{\\wt H_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}\n  =-i\\omega\\VMV{ \\wt{\\vb E }\\sup{des}         }\n               { \\bmc{G}\\sup{ME}              }\n               { \\boldsymbol{\\delta}_i\\sup{obj} }\n \\tag{3a}\n\\\n \\hphantom{\\pard{\\wt H_i(\\vb{x}\\sup{obj})}{\\epsilon\\sup{des}}}\n   =+i\\omega\\VMV{ \\wt{\\vb E}\\sup{des}          }\n                { \\bmc{G}\\sup{EM}              }\n                { \\boldsymbol{\\delta}_i\\sup{obj} }\n \\tag{3b}\n\\end{align }\nwhere in going to the last line we invoked the identity \\bmc{G}\\sup{EM}=-\\bmc{G}\\sup{ME}. \\bmc{G}\\sup{EM}=-\\bmc{G}\\sup{ME}.  Note that equations (3a) and (3b), notwithstanding their nearly\nidentical appearance, describe two rather different meep  calculations: In the former case\nwe place an electric source at  \\vb x\\sup{obj} \\vb x\\sup{obj}  and timestep to\ncompute the resulting magnetic field, while in the latter\ncase we place a magnetic source and timestep\nto compute the resulting electric field. (In both cases,\nupon computing the field in question we proceed to compute its\noverlap with the unperturbed  \\vb E \\vb E  field in the design region.)", 
            "title": "Invoking reciprocity"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#differentiating-more-complicated-functions-of-field-components", 
            "text": "Thus far we have only considered derivatives of individual\nfield components, and then only at a single point  \\vb{x}\\sup{obj} \\vb{x}\\sup{obj} ;\nmore generally, we will want to differentiate functions of\nmultiple field components over a subregion of the grid,\nwhich we will call the  objective region   \\mc{V}\\sup{obj} \\mc{V}\\sup{obj} .", 
            "title": "Differentiating more complicated functions of field components"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#e-field-energy-in-region", 
            "text": "As one example, the electric field energy in the objective\nregion is defined by an integral over that region, which  meep \napproximate by a weighted sum over grid points:\n$$ \\mc{E}=\n   \\frac{1}{2}\\int_{\\mc{V}\\sup{obj}} \\epsilon |\\wt{\\vb E}|^2 \\,d\\mc{V}\n   \\approx\n   \\frac{1}{2}\\sum_{i,\\vb{n}\\in\\mc{V}\\sup{obj}} w_{\\vb{n}}\n   \\epsilon_\\vb {n} \\wt E_{i\\vb n}^* \\wt E_{i\\vb n}\n$$\nHere the sum is over all field components  i=\\{x,y,z\\} i=\\{x,y,z\\}  and\nall grid points  \\vb{n} \\vb{n}  lying in  \\mc{V}\\sup{obj} \\mc{V}\\sup{obj} ,\nand  w_{\\vb{n}} w_{\\vb{n}}  is a cubature weight associated with point  \\vb{n} \\vb{n} \n(as returned by  get_dft_array_metadata ).\nDifferentiating, we have\n\\begin{align }\n \\pard{\\mc E}{\\epsilon\\sup{des}}\n  =\\text{Re }\\sum_{i\\vb{n}\\in\\mc V\\sup{obj}} w_{\\vb n}\\epsilon_{\\vb n}\n   \\wt{E}^ {i\\vb n} \\pard{\\wt{E} } {\\epsilon\\sup{des}}\n\\ \\hspace{-1.5in}\\text{Insert equation (1a):}\n\\\n  =\\text{Re }\\left{ -i\\omega \\VMV{\\epsilon \\wt{\\vb E}\\sup{obj }}\n                                   {{\\bmc G}\\sup{EE}}\n                                   {\\wt{\\vb E}\\sup{des}}\n              \\right}\n\\ \\hspace{-1.5in}\\text{Invoke reciprocity:}\n\\\n  =\\text{Re }\\left{ -i\\omega \\VMV{\\wt{\\vb E}\\sup{des}}\n                                  {{\\bmc G}\\sup{EE}}\n                                  {\\epsilon \\wt{\\vb E}\\sup{obj }}\n              \\right}\n\\end{align*}", 
            "title": "E-field energy in region"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#poynting-flux", 
            "text": "A case that arises frequently is that in which the objective region\nis a cross-sectional surface  \\mc S\\sup{obj} \\mc S\\sup{obj}  cutting normally through a\nwaveguide or similar structure and the objective function is the \nnormal Poynting flux through  \\mc S \\mc S .\nFor example, the  x x -directed Poynting flux is given by\n$$\n S_x\n=\n\\frac{1}{2}\\text{Re }\\left{ \\int_{\\mc S\\sup{obj}} \\Big(E^ y H_z + \\cdots\\Big) \\, d\\mathbf{x} \\right}\n\\approx \\frac{1}{2}\\text{Re }\\sum } w_{\\vb n}\n \\Big(E^ {y\\vb n} H  + \\cdots\\Big)\n$$\nwhere  \\cdots \\cdots  refers to three other terms of the form  \\pm E^*_i H_j \\pm E^*_i H_j .\nDifferentiating and rearranging slightly, we have\n\\begin{align }\n \\pard{S_x}{\\epsilon\\sup{des}}\n  =\\text{Re }\\sum_{\\vb n\\in \\mc S\\sup{obj}} w\n   \\left{ \\wt{E}^ _{y} \\pard{\\wt{H}_z}{\\epsilon\\sup{des}}\n          +\\wt{H}^ {z} \\pard{\\wt{E}_y}{\\epsilon\\sup{des}}\n         +\\cdots\n   \\right}\n\\[5pt] \\hspace{-0.5in}\\text{Use (1a) and (1b):}\n\\[5pt]\n  =\\text{Re }\\left{ -i\\omega \\VMV{\\wt{\\vb E} \\sup{obj }}\n                                  {\\bmc G\\sup{ME}}\n                                  {\\wt{\\vb E}\\sup{des}}\n                     -i\\omega \\VMV{\\wt{\\vb H}_z\\sup{obj }}\n                                  {\\bmc G\\sup{EE}}\n                                  {\\wt{\\vb E}\\sup{des}}\n                     +\\cdots\n            \\right} \n\\[5pt] \\hspace{-0.5in}\\text{Use reciprocity:}\n\\[5pt] =\\text{Re }\\left{ -i\\omega  \\VMV{\\wt{\\vb E}\\sup{des}}\n                                  {\\bmc G\\sup{ME}}\n                                  {\\wt{\\vb E}_y\\sup{obj }}\n                    -i\\omega \\VMV{\\wt{\\vb E}\\sup{des}}\n                                 {\\bmc G\\sup{EE}}\n                                 {\\wt{\\vb H}_z\\sup{obj }}\n                    +\\cdots\n              \\right}\n\\end{align }", 
            "title": "Poynting flux"
        }, 
        {
            "location": "/AdjointSolver/AdjointImplementationNotes/#mode-coefficient", 
            "text": "$$ \\alpha_m^\\pm = C_1 \\pm C_2 $$\n\\begin{align }\n C_1  =\\frac{1}{\\mathcal{N}}\n   \\int_{\\mc S\\sup{obj}} \\Big(e^ _y H_z - e^ z H_y\\Big)d\\mathbf{x}\\\n C_2  =\n   \\frac{1}{\\mathcal{N}}\\int } \\Big(h^ _z E_y - h^ _y E_z\\Big)d\\mathbf{x}\\\n\\end{align }", 
            "title": "Mode coefficient"
        }
    ]
}